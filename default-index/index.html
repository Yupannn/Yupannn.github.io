<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yupannn.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-1}}},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="盂盘的blog">
<meta property="og:url" content="https://yupannn.github.io/default-index/index.html">
<meta property="og:site_name" content="盂盘的blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yupannn">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://yupannn.github.io/default-index/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>盂盘的blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">盂盘的blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yupannn</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2025/03/07/LinuxExperience/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/03/07/LinuxExperience/" class="post-title-link" itemprop="url">Linux初体验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-03-07 08:14:23 / 修改时间：12:24:17" itemprop="dateCreated datePublished" datetime="2025-03-07T08:14:23+08:00">2025-03-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><del>其实并不是初体验，只是初次装在自己电脑上</del></p>
<h1 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h1><p>下载安装了 VMware Workstation Pro</p>
<p>注意下载最新版的，全面免费，不用输入许可密钥激活</p>
<p>其实这一步没啥好写的，按照安装向导的提示来操作就是了</p>
<h1 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h1><p>打开 VMware ，</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2025/02/28/RSA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/28/RSA/" class="post-title-link" itemprop="url">RSA</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-28 23:46:04" itemprop="dateCreated datePublished" datetime="2025-02-28T23:46:04+08:00">2025-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-26 14:06:16" itemprop="dateModified" datetime="2025-05-26T14:06:16+08:00">2025-05-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id><a href="#" class="headerlink" title></a></h1><h1 id="RSA常见攻击方式"><a href="#RSA常见攻击方式" class="headerlink" title="RSA常见攻击方式"></a>RSA常见攻击方式</h1><h2 id="Elementary-Attacks"><a href="#Elementary-Attacks" class="headerlink" title="Elementary Attacks"></a>Elementary Attacks</h2><h3 id="共模攻击-Common-Modulus-重复使用模数N"><a href="#共模攻击-Common-Modulus-重复使用模数N" class="headerlink" title="共模攻击(Common Modulus 重复使用模数N)"></a>共模攻击(Common Modulus 重复使用模数N)</h3><p>$ (N,e_1),(N,e_2) $ 分别是 Alice 和 Bob 所持有的公钥，$ d_1,d_2 $ 分别是对应的私钥</p>
<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>已知 $ c_1&#x3D;encrypt(N,e_1,m) c_2&#x3D;encrypt(N,e_2,m) $</p>
<p>若互素，$ gcd(e_1,e_2)&#x3D;1 $</p>
<p>求出 $ e_1<em>s_1+e_2</em>s_2&#x3D;1 $ 的一组解，则 $ m&#x3D;e_1^{s_1}*e_2^{s_2} $</p>
<p>证明：<br>$ c_1^{s_1}<em>c_2^{s_2}&#x3D;m^{d_1</em>s_1}<em>m^{d_2</em>s_2}&#x3D;m^{d_1<em>s_1+d_2</em>s_2}\equiv m \pmod N $</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">s, s1, s2 = gmpy2.gcdext(e1,e2)</span><br><span class="line">m=<span class="built_in">pow</span>(c1,s1,n)*<span class="built_in">pow</span>(c2,s2,n)%n</span><br></pre></td></tr></table></figure>
<p>若不互素：<br>求出 $ e_1*s_1+e_2s_2&#x3D;gcd(e_1,e_2) $的一组解</p>
<p>$ c_1^{s_1}*c_2^{s_2}&#x3D;m^{gcd(e_1,e_2)}\pmod N $</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">t, s1, s2 = gmpy2.gcdext(e1, e2)</span><br><span class="line">m = gmpy2.iroot(<span class="built_in">pow</span>(c1, s1, n)*<span class="built_in">pow</span>(c2, s2, n) % n, t)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><h3 id="Blinding-盲签名"><a href="#Blinding-盲签名" class="headerlink" title="Blinding 盲签名"></a>Blinding 盲签名</h3><p>Marvin 本来想要 Bob 给消息 M 签名，但 Bob 不签</p>
<p>所以他随机取数 r ，计算$ M’&#x3D;r^eM $，现在 Bob 给 M’ 签了名：$ S’\equiv (M’)^d \pmod N $</p>
<p>可计算得到 M 的签名 $ S&#x3D;(S’)&#x2F;r $</p>
<p>验证：<br>$ S^e&#x3D;(S’)^e&#x2F;r^e\equiv (M’)^{ed}&#x2F;r^e\equiv (M’)&#x2F;r^e\equiv M \pmod N $</p>
<h2 id="Low-Private-Exponent-私钥过小"><a href="#Low-Private-Exponent-私钥过小" class="headerlink" title="Low Private Exponent 私钥过小"></a>Low Private Exponent 私钥过小</h2><h2 id="Low-Public-Exponent-公钥过小"><a href="#Low-Public-Exponent-公钥过小" class="headerlink" title="Low Public Exponent  公钥过小"></a>Low Public Exponent  公钥过小</h2><h3 id="Coppersmith"><a href="#Coppersmith" class="headerlink" title="Coppersmith"></a>Coppersmith</h3><hr>
<h2 id="一些示例"><a href="#一些示例" class="headerlink" title="一些示例"></a>一些示例</h2><h2 id="dp泄露"><a href="#dp泄露" class="headerlink" title="dp泄露"></a>dp泄露</h2><p>dp的定义为：</p>
<p>$ dp \equiv d \mod （p-1） $</p>
<p>dp包含了 d 和 p 的某种关系，一般情况下只要求出了它，就能顺带求出其他的值<br>证明如下：</p>
<p>已知 $ dp \equiv d \mod (p-1),de \equiv 1 \mod (p-1)(q-1) $</p>
<p>故 $ dp*e \equiv de \mod (p-1),de&#x3D;k_1(p-1)(q-1)+1 $</p>
<p>$ dp*e&#x3D;k_2(p-1)+de&#x3D;k_2(p-1)+k_1(p-1)(q-1)+1&#x3D;(p-1)K+1 $</p>
<p>而 $ 0&lt;&#x3D;dp&lt; p-1 $</p>
<p>则 $ 0&lt; K&lt; e $</p>
<p>只需要遍历 K 的值，找出一个刚好能除出来一个整数的值就行了<br>同时检查一下找出的 p 能否整除 n</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#已知dp的情况下：</span></span><br><span class="line"><span class="keyword">for</span> K <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,e) :</span><br><span class="line">    <span class="keyword">if</span> (dp*e-<span class="number">1</span>)//K==<span class="number">0</span> :</span><br><span class="line">        p=(dp*e-<span class="number">1</span>)//K</span><br><span class="line">        <span class="keyword">if</span> n%p==<span class="number">0</span> :</span><br><span class="line">            q=n//p</span><br><span class="line">            phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">            d=gmpy2.inverse(e,phi)</span><br><span class="line">            flag=<span class="built_in">pow</span>(m,d,n)</span><br></pre></td></tr></table></figure>

<h2 id="e超小"><a href="#e超小" class="headerlink" title="e超小"></a>e超小</h2><p>如果 e 特别小，就直接遍历 n 然后乘方<br>gmpy2里的iroot会返回一个元组(root,exact)，root为计算得到的方根，exact为true或false，表示计算是否精确<br>可以用来判断结果是否为整数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e=<span class="number">3</span></span><br><span class="line">k=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    flag=gmpy2.iroot(k*n+c,e)</span><br><span class="line">    <span class="keyword">if</span> m[<span class="number">1</span>]==<span class="number">0</span> :</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2025/02/28/lattice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/28/lattice/" class="post-title-link" itemprop="url">lattice格密码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-28 23:45:27" itemprop="dateCreated datePublished" datetime="2025-02-28T23:45:27+08:00">2025-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-07 08:12:40" itemprop="dateModified" datetime="2025-03-07T08:12:40+08:00">2025-03-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>以下内容基本可以看作《An Introduction to mathematical cryptography》里格密码部分的中文精简版（</p>
<p>在进入正题之前，先讲两个例子（其实可以跳过）</p>
<h2 id="例一、某种一致的公钥加密系统"><a href="#例一、某种一致的公钥加密系统" class="headerlink" title="例一、某种一致的公钥加密系统"></a>例一、某种一致的公钥加密系统</h2><p>( A congruential public key cryptosystem )</p>
<p>Bob 要给 Alice 发送信息，假设他们按如下规则进行通信：</p>
<ol>
<li>Alice 随便选三个正整数 $ q,f,g (f&lt; \sqrt{q&#x2F;2} ,\sqrt{q&#x2F;4} &lt;g&lt; \sqrt{q&#x2F;2} ,gcd(f,g)&#x3D;1 ) $ ，其中 q 是公开的，f,g 是私密的</li>
<li>Alice 计算 $ h \equiv f^{-1}g \pmod q $ 得到 h 作为公钥</li>
<li>Bob 想要把明文 m 发送给 Alice ，随机选了一个整数 r ，满足 $ 0&lt; m &lt; \sqrt{q&#x2F;4},0&lt; r&lt; \sqrt{q&#x2F;2} $</li>
<li>Bob 计算 $ e \equiv rh+m \pmod q ,0&lt; e&lt; q $，得到密文 e 并把 e 发送给 Alice</li>
<li>Alice 收到 e 后计算 $ a \equiv fe \pmod q,0&lt; a&lt; q ,$<br>$ b \equiv f^{-1}a \pmod g,0&lt; b&lt; g,f^{-1}f \equiv 1 \pmod g $ ,得到的 b 就等于 m，解密结束</li>
</ol>
<details>
<summary>点击看证明过程</summary>
<div>

<p>$ a \equiv fe \equiv f(rh+m) \equiv frf^{-1}g+fm \equiv rg+fm \pmod q $</p>
<p>而由已知的数据范围有：$ rg+fm&lt; \sqrt{\frac{q}{2}}\sqrt{\frac{q}{2}}+ \sqrt{\frac{q}{2}}\sqrt{\frac{q}{4}}&lt; q $<br>而 $ 0&lt; a&lt; q $<br>则 $ a&#x3D;rg+fm $<br>$ b \equiv f^{-1}a \equiv f^{-1}(rg+fm) \equiv m \pmod g ,0&lt; b&lt; g $<br>又因为 $ m&lt; \sqrt{q&#x2F;4}&lt; g $ ，可以得出 b &#x3D; m</p>
<blockquote>
<p>以上证明了为何 b &#x3D; m ，下面我试图从发明这个算法的角度思考</p>
<p>首先它肯定是希望通过<strong>同余</strong>来隐藏原信息，也就是加密方借助取模环境下的运算让明文的面目模糊化，解密方再用已经知道的一些参数把密文还原</p>
<p>假设明文是 m ，在模 q 情景中打算用一种<strong>公钥加密，私钥解密</strong>的方式设计这个加密系统<br>那么肯定要存在一个公钥 h ，并用 h 对 m 进行一些运算上的处理<br>为了使这个系统更复杂更难以被破解，于是引入一个<strong>随机数</strong> r 参与到对 m 的运算中</p>
<p>现在有了三个数：m , h , r ，然后可以随意设计它们之间怎样进行加减乘除甚至乘方<br>不过得注意，应该把明文 m 和随机数 r 的运算区分开，不能混在一起，不然解密方只能得到这两个数的混合产物<br>比如 $ e \equiv h(m+r) \pmod q 或者e \equiv h+mr \pmod q $，<br>这样最后哪怕得出了结果 m+r 或 mr ，也是无法把 m 分离出来的</p>
<p>这样一来，很容易想到这样设计： $ e \equiv hm+r \pmod q $ 或 $ e \equiv hr+m \pmod q $<br>再考虑到，解密方解密数据的方式是使用能“抵消”公钥的私钥 f 对密文进行运算，在这个情景下，暂且把这个运算当作是作乘法<br>对于前一种设计，h 可以被 f “抵消”掉，而 r 却不能，所以我就简单粗暴地把这个方案 pass 了<br>而后一种设计，看起来的确可以只把 m 给留下，所以就采用这个方案了</p>
<p>既然前面对于解密运算定的是作乘法，那么为了除掉随机数 r ，<br>$ f(hr+m) \pmod q $ 中的 fh 一项一定能被约掉<br>如果让我自己来构想的话，大概就直接简单地把 fh 设置成 q 的倍数了<br>但本例中却是把 fh 设置成了私钥 g 的倍数，<br>即 $ fhr+fm \equiv kg+fm \equiv fm \pmod g $ ，f 和 g 对于解密方是已知的，自然就能求出 f 的逆元解出 m </p>
<p>当然，上面过程中有些地方相当于直接忽略了取模，但通过控制数据范围，能够实现把同余符号当作等号，就如上上面证明过程里写的那样</p>
</blockquote>
</div>
</details>

<p>从攻击者 Eve 的角度看这个过程，能发现解密的关键在于 f 和 g<br>已知 h 和 q ，只需要凑出一对 F 和 G 满足 $ Fh \equiv G \pmod q ,F&#x3D; \mathcal{O}(\sqrt{q}),G &#x3D; \mathcal{O}(\sqrt{q})$<br>即 $ Fh&#x3D;G+qR ,R \in Z $<br>看着很像线性代数里的东西，用另一种形式来写就是<br>$ F(1,h)-R(0,q)&#x3D;(F,G) $，其中两个向量是已知的，<br>$ \mathbf{v_1}&#x3D;(1,h), \mathbf{v_2}&#x3D;(0,q) $</p>
<p>此时，问题就变成了在向量集合 $ L&#x3D; \lbrace a_1\mathbf{v_1}+a_2\mathbf{v_2} :a_1,a_2 \in \mathbb{Z} \rbrace $ 中找一个非零向量<br>即找 v1 和 v2 的整数线性组合<br>这个 L 就是一个二维的格</p>
<h2 id="例二、子集和问题，背包密码系统"><a href="#例二、子集和问题，背包密码系统" class="headerlink" title="例二、子集和问题，背包密码系统"></a>例二、子集和问题，背包密码系统</h2><p>( Subset-sum problems and knapsack cryptosystems )</p>
<p><strong>子集和问题</strong>，顾名思义，和集合子集中的元素和有关</p>
<p>给定一个集合 $ (M_1,M_2,…,M_n),M_i \in N^+ $<br>要求找出它的一个子集，使得子集内的整数和为 S</p>
<p>相当于求一个二进制数转化成的向量 $ x&#x3D;(x_1,x_2,…,x_n),x_i &#x3D;1 或 0 $ ，<br>使得 $ S&#x3D;\sum^n_{i&#x3D;1}x_iM_i $</p>
<p>把 x 看作明文，把 S 看作密文，这就是一个粗糙的加密机制了<br>但是问题是解密方能获取的信息攻击方也能获取，这下敌我不分了<br>而且如果想要把原信息解出来，通过遍历所有的 n 长度的二进制向量效率太低，时间复杂度 $ \mathcal{O}(2^n) $</p>
<p>有一个巧妙的方法可以降低时间复杂度<br>用两个列表表示 x 的前半部分和后半部分数字的集合：<br> $ \mathbf{I} \in \lbrace i:1 \le i \le \frac{1}{2}n \rbrace ,\mathbf{J} \in \lbrace j:\frac{1}{2}n \le j \le n \rbrace $<br>预先计算 $ A_{\mathbf{I}}&#x3D;\sum_{i \in \mathbf{I}}M_i,B_{\mathbf{J}}&#x3D;S-\sum_{j \in \mathbf{J}}M_j $<br>则问题转化成了找到一组 $ \mathbf{I_0},\mathbf{J_0} 使得 A_{\mathbf{I_0}}&#x3D;B_{\mathbf{J_0}},S&#x3D;\sum_{i \in \mathbf{I_0}}M_i+\sum_{j \in \mathbf{J_0}}M_j $<br>现在遍历的时间复杂度降到了 $ \mathcal{O}(2^{n&#x2F;2}) $</p>
<blockquote>
<p>这种把数据砍一半再<strong>归并</strong>的思想，常见于多种算法和数据结构，如<strong>快速排序</strong>、<strong>线段树</strong>等等</p>
</blockquote>
<p>现在再来解决另一个问题：怎样使得只有解密方才能轻松解密呢？</p>
<p>定义一种<strong>爆炸性增长的数列 r</strong>，使得<br>$ \mathbf{r}&#x3D;(r_1,r_2,…,r_n),r_{i+1}&gt; 2r_i ,1 \le i \le n-1 $<br>所以 $ r_k&gt; r_{k-1}+…+r_2+r_1 ,2 \le k \le n $</p>
<details>
<summary>证明过程</summary>
<div>

<p>使用<strong>数学归纳</strong>法</p>
<p>k&#x3D;2 时，$ r_2 \ge 2r_1&gt; r_1 $，成立<br>k&gt;2 时，假设 $ r_{k-1}&gt;r_{k-2}+…r_1 $<br>则 $ r_k \ge 2r_{k-1}&gt; r_{k-1}+r_{k-2}+…+r_1 $，也成立<br>故 $ r_k &gt; r_{k-1}+…+r_1,2 \le k \le n $</p>
</div>
</details>

<p>用 ( M , S ) 构造一个子集和问题，其中 M 是一个爆炸性增长的数列<br>解密方案如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span> S &gt;= M[i]:</span><br><span class="line">        x[i]=<span class="number">1</span></span><br><span class="line">        S-=M[i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x[i]=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>经过调整后的方案如下：<br>Bob 要和 Alice 发信息，他们按如下规则通信：</p>
<ol>
<li>Alice 选出一个爆炸性增长的数列 $ \mathbf{r}&#x3D;(r_1,…,r_n) $<br> 以及数 $ A,B,B&gt;2r_n,gcd(A,B)&#x3D;1 $</li>
<li>Alice 计算出 $ M_i &#x3D; Ar_i \pmod B ,1 \le i \le n $<br> 这个 $ M&#x3D;(M_1,…,M_n) $ 即为公钥</li>
<li>Bob 把明文转化成二进制得到 x ，计算 $ S&#x3D;x · M $ 作为密文并发送给 Alice</li>
<li>Alice 首先计算 $ S’ \equiv A^{-1}S \equiv x·r \pmod B $ ，<br> 再使用子集和问题的解法解出 x</li>
</ol>
<p>像这样基于子集和问题的密码系统就叫做<strong>子集和密码系统</strong>或者<strong>背包密码系统</strong></p>
<blockquote>
<p>话说背包密码系统这个名字总是让我想起算法里的<strong>0-1背包</strong>，<br>感觉这两者研究的问题其实差不多</p>
</blockquote>
<p>用向量来表示的话，就能看出这种问题是怎么和格联系起来的了<br>假设数 S 和集合 $ M&#x3D;(m_1,…,m_n) $ 构成一个子集和问题</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2025/02/28/unity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/28/unity/" class="post-title-link" itemprop="url">unity</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-28 23:45:13" itemprop="dateCreated datePublished" datetime="2025-02-28T23:45:13+08:00">2025-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-02 23:21:53" itemprop="dateModified" datetime="2025-03-02T23:21:53+08:00">2025-03-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>边做项目边学，边学边写博客</p>
<h1 id="认识unity的界面"><a href="#认识unity的界面" class="headerlink" title="认识unity的界面"></a>认识unity的界面</h1><p><del>unity的下载安装很简单，所以就不写了</del></p>
<p>在unity hub中创建项目时，可以看到有很多选项，作为新手暂时就不去研究这些了，直接选个标准模板，2d或3d都行<br>这里先选个3d的看看</p>
<p>创建之后是这样的界面</p>
<p><img src="https://note.youdao.com/ynoteshare/index.html?id=301887741cdc38c7d6134b9a1da68246&type=note&_time=1740928882671" alt="hub"></p>
<p>如图，常用的界面分别有<br><strong>Hierarchy</strong>    显示当前游戏场景里面存放了哪些东西<br><strong>Scene</strong>   显示场景，在这里调整游戏内物品的摆放<br><strong>Animator</strong>    用于控制动画<br><strong>Game</strong>    进入游戏后的视角，即摄像机视角<br><strong>Inspector</strong>   编辑游戏对象的属性等<br><strong>Project</strong> 存放资源文件，相当于仓库<br><strong>Console</strong> 控制台，可以用来调试</p>
<h2 id="导入资源"><a href="#导入资源" class="headerlink" title="导入资源"></a>导入资源</h2><p>创建游戏对象的方式有很多</p>
<ul>
<li>在<strong>Hierarchy</strong>界面按鼠标右键，然后选一个</li>
<li>把事先准备好的资源文件（比如人物建模，背景图像之类的）拖到<strong>Project</strong>，一般就存在Assets文件夹里，然后再从<strong>Project</strong>里拖到<strong>Hierarchy</strong>里</li>
<li>从资源商店里导入资源，再从<strong>Project</strong>里拖到<strong>Hierarchy</strong>里<blockquote>
<p><strong>从资源商店获取资源：</strong><br>顶栏里的windows -&gt; Asset Store，登录后能找到很多免费的素材<br><strong>导入资源：</strong><br>顶栏里的windows -&gt; Package Manager，把顶栏左边的 Packages 选成 My Assets，找到资源后点击 import 导入</p>
</blockquote>
</li>
</ul>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2024/11/02/clib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/02/clib/" class="post-title-link" itemprop="url">C和C++常用库函数（防忘）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-02 12:23:40" itemprop="dateCreated datePublished" datetime="2024-11-02T12:23:40+08:00">2024-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-22 18:30:00" itemprop="dateModified" datetime="2024-11-22T18:30:00+08:00">2024-11-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id><a href="#" class="headerlink" title="&lt;stdio.h&gt;"></a>&lt;stdio.h&gt;</h1><h2 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h2><blockquote>
<p>用C语言使用标准输入输出需要包含&lt;stdio.h&gt;<br>用C++时还可以用iostream代替</p>
</blockquote>
<p>int scanf(…)</p>
<blockquote>
<p>返回正确输入的参数的个数<br>不会死循环的循环输入，用于读取文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123; <span class="comment">//EOF: End Of File ，文件末尾会有的标志，本质是-1</span></span><br><span class="line">   ... <span class="comment">//或者把!=EOF换成==1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按Ctr+C或者Ctr+Z+Enter结束输入</p>
</blockquote>
<p>int printf(…)</p>
<blockquote>
<p>返回打印字符（包括不可见的字符如空格和换行符）的个数，<br>如果有输入错误则返回一个负值</p>
</blockquote>
<h3 id="常用格式占位符"><a href="#常用格式占位符" class="headerlink" title="常用格式占位符"></a>常用格式占位符</h3><p>%d 整数<br>%ld 长整型<br>%f 浮点数<br>%lf 双精度double类型浮点数<br>%e 用科学计数法表示的浮点数，指数部分的e小写<br>%E 用科学计数法表示的浮点数，指数部分的E大写 </p>
<blockquote>
<p>默认情况（没有指定输出宽度时）下小数点后输出6位，指数占4位<br>例：printf(“%e”,123.456);<br>输出”1.234560e+02”</p>
</blockquote>
<p>%c 字符<br>%o 八进制整数<br>%x 十六进制整数<br>%u 无符号十进制整数<br>%p 指针<br>%s 字符串</p>
<blockquote>
<p>使用字符指针给定字符串的初始位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> q[n];</span><br><span class="line"><span class="type">char</span>* p=q;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,&amp;q[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//这三个printf 等价</span></span><br></pre></td></tr></table></figure>
<p>使用scanf时从初始位置一直读取，读到空字符null（’\0’）或者空白字符时结束<br>（读取后不存入数据且仍留在缓冲区里）</p>
<blockquote>
<p>空字符(Null character)是ASCII码为0的字符，缩写为NUL，通常作为结束符出现，也可以写作\0<br>输入字符串时scanf自动在末尾加上\0<br>另：NUL和NULL不是一个意思，虽然它们值都等于0，但前者表示’\0’这个字符常量，后者表示一个值为0的空指针，且定义NULL的头文件是另一个，而NUL没有被定义，所以不能直接用</p>
</blockquote>
<p>因此它不适用于包含空格或换行符制表符的字符串输入</p>
</blockquote>
<h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p><strong>右对齐</strong>  在%后加数字最小宽度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,<span class="number">2</span>);<span class="comment">//输出&quot;_2&quot;，用空格补齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02d&quot;</span>,<span class="number">2</span>);<span class="comment">//输出&quot;02&quot;，用0补齐</span></span><br></pre></td></tr></table></figure>
<p>如果要打印的位数小于最小宽度，则在前面补足；如果大于最小宽度，则打印所有的数字，不会截断<br><strong>左对齐</strong> 类似于右对齐，只是在%后还要加-</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-2d&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//输出为 &quot;2_&quot; （2后面加了1个空格，好像不能用0补齐？）</span></span><br></pre></td></tr></table></figure>

<p>对于浮点数，上述两种表示方法都会让它在最后一位后面补零，使总长度（包括小数点）不小于最小宽度<br>但补零一般都用”.”来控制小数部分位数<br>例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%8lf&quot;</span>,<span class="number">0.345</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-8lf&quot;</span>,<span class="number">0.345</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.8lf&quot;</span>,<span class="number">0.345</span>);</span><br><span class="line"><span class="comment">//前两行都输出 &quot;0.345000&quot;</span></span><br><span class="line"><span class="comment">//第三行输出 &quot;0.34500000&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于字符串，”.”的用法和整数的”-“相似<br>还多了一个”*”的用法<br>例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%*s&quot;</span>,<span class="number">4</span>,<span class="string">&quot;abc&quot;</span>); <span class="comment">//至少输出4个字符，如果少于则在左边补空格，这里输出&quot;_abc&quot;（_表示空格）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.*s&quot;</span>,<span class="number">2</span>,<span class="string">&quot;abc&quot;</span>); <span class="comment">//最多输出2个字符，超出的部分会截断，这里输出&quot;ab&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%*.*s&quot;</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="string">&quot;abc&quot;</span>); <span class="comment">//第一个*表示总共至少输出5个字符，第二个*表示总共最多输出所给字符串的2个字符</span></span><br><span class="line"><span class="comment">//混合的结果就是输出&quot;___ab&quot;，在ab前面补了三个空格</span></span><br></pre></td></tr></table></figure>


<h3 id="常用转义字符"><a href="#常用转义字符" class="headerlink" title="常用转义字符"></a>常用转义字符</h3><p>%% “%”<br>\n 换行<br>\r 回车，将当前位置移到本行开头<br>\t 水平制表符（&#x3D;tab键）<br>\ “&quot;<br>&#39; “‘“<br>&quot; “””<br>\0 空字符NUL<br>\a 响铃 </p>
<hr>
<p>char* gets()</p>
<blockquote>
<p>读取一行字符串，只会在遇到\n时才停止，<br>因为它不检查输入字符的个数，容易造成溢出等问题，所以早就被ban了</p>
</blockquote>
<p>int puts(char* s)</p>
<blockquote>
<p>虽然gets不能用了，但puts还活得好好的<br>只能输出一行，并且会在字符串后自动添加换行符<br>返回值为字符串长度（包括末尾的\0），如果发生错误则返回EOF</p>
</blockquote>
<p>int getchar(void)</p>
<blockquote>
<p>只读取缓存区的一个字符，返回值为该字符的ASCII码值，读取失败时返回EOF<br>接受空格符和换行符，所以有时可能误读了前面残留的\n，这时就得提前清空缓存区</p>
</blockquote>
<p>int putchar(char c)</p>
<blockquote>
<p>返回值为该字符的ASCII码值</p>
</blockquote>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><blockquote>
<p>FILE 是一种数据类型，是预定义的一个struct，用于管理文件流<br>常见的有stdin,stdout,stderr等<br>FILE* 是指向FILE类型数据的指针</p>
</blockquote>
<p>FILE* freopen(const char* path,const char* mode,FILE* stream)</p>
<blockquote>
<p>把原先的标准流文件（stdin（默认为键盘）,stdout（默认为屏幕）,stderr（默认为屏幕））<br>重定向到由path指定的文件中<br>返回值为path所指定文件的指针，若重定向失败则返回NULL（空指针，0）</p>
</blockquote>
<p><strong>mode模式：</strong><br>“r” read，只读，文件必须存在<br>“w” write，创建一个只能写入的空文件，若文件名已存在，则删除原有文件的内容<br>“a” append，追加，若文件不存在则创建文件<br>“r+”    打开一个已存在的文件，可读也可写<br>“w+”    创建一个用于读写的空文件<br>“a+”    读取+追加</p>
<p>int fclose(FILE* stream);</p>
<blockquote>
<p>关闭stream流，如果成功则返回0，如果失败则返回EOF（-1）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;file1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="comment">//将输入重定向到file1这个文件，从file1中读取数据</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="comment">//将输出重定向到file2这个文件中，将数据输出到file2中</span></span><br><span class="line"><span class="built_in">fclose</span>(stdin);<span class="comment">//关闭重定向输入</span></span><br><span class="line"><span class="built_in">fclose</span>(stdout);<span class="comment">//关闭重定向输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者这样写</span></span><br><span class="line">FILE* f1,f2;</span><br><span class="line">f1=<span class="built_in">freopen</span>(<span class="string">&quot;file1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">f2=<span class="built_in">freopen</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="built_in">fclose</span>(f1);</span><br><span class="line"><span class="built_in">fclose</span>(f2);</span><br></pre></td></tr></table></figure>

<h1 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a>iostream</h1><blockquote>
<p>不知道为什么在iostream两边加上&lt;&gt;，网站上它就显示不出来了……</p>
</blockquote>
<blockquote>
<p>是C++的标准库而不是C的<br>要加 using namespace std;</p>
</blockquote>
<p>cin&gt;&gt;</p>
<blockquote>
<p>读到空白字符就停止输入，且既不读入也不在缓冲区清除该空白字符<br>特殊地，如果还没读入数据就遇到空白字符，则忽略并清除它们，然后继续读取</p>
</blockquote>
<p>cin.getline(char* s,int n,char c)</p>
<blockquote>
<p>只读一行，读取到换行符后就结束<br>（不将换行符读入数据，但会在缓冲区中清除掉这个换行符）<br>s表示接收字符串的变量<br>n表示字符个数（超出时会截断）<br>c可写可不写，表示（在一行内）遇到c就结束输入，省略情况下默认为’\0’</p>
</blockquote>
<p>getline(cin,string s)</p>
<blockquote>
<p>搭配另一个头文件&lt;string.h&gt;使用<br>和上面那个读取方式类似<br>可以用它读取带空格的一整行</p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>sizeof ( ) 返回在内存中所占的存储空间，单位是字节 byte</p>
<blockquote>
<p>是单目运算符，不是函数哦</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span> ; <span class="type">double</span> b = <span class="number">1</span> ;</span><br><span class="line"><span class="type">int</span> arr [ ] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> &#125;</span><br><span class="line"><span class="type">char</span> str [ ] = <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span> , <span class="built_in">sizeof</span>(a), <span class="built_in">sizeof</span>(b), <span class="built_in">sizeof</span>(arr), <span class="built_in">sizeof</span>(str) );</span><br><span class="line"><span class="comment">//输出为 : 4 8 12 6</span></span><br><span class="line"><span class="comment">//计算数组存储空间时：3（元素个数；int类型数据数量）*4（每个int类型数据所占字节）=12</span></span><br><span class="line"><span class="comment">//计算字符串时：5+1（使用“ ”表示字符串时会自动在最后面加上 &#x27;\0&#x27;（或者说是NULL））=6</span></span><br></pre></td></tr></table></figure>
<p>返回值类型为 size_t 类型，好像新标准以来就得用%zd不能用%d了……？<br>在不同的机器上它实际上的类型可能各不相同<br>总之用%d没问题的话就用%d，否则就试试%zd或者%lu<br>对结构体使用sizeof的过程意外地很复杂<br>涉及到一点硬件方面的东西<br>就结果而言，返回的是和你手算加出来的那个数最接近的结构体中最长字段长度的整数倍</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">a</span>&#123;</span><br><span class="line">       <span class="type">char</span> x ; <span class="comment">//sizeof( x )  为1</span></span><br><span class="line">       <span class="type">short</span> y ; <span class="comment">//sizeof( y ) 为2</span></span><br><span class="line">       <span class="type">int</span> z ; <span class="comment">//sizeof( z ) 为4</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//sizeof( a )返回的是8，不是7</span></span><br><span class="line"><span class="comment">//算出的是7，而结构体中最长字段为（int）4，所以结果为最接近的4的整数倍，8</span></span><br></pre></td></tr></table></figure>
<p>这就是字节对齐，更详细的我暂时懒得深究了orz</p>
</blockquote>
<h1 id="-1"><a href="#-1" class="headerlink" title="&lt;conio.h&gt;"></a>&lt;conio.h&gt;</h1><p>int getch(void)</p>
<blockquote>
<p>和getchar类似，只读单个字符，并返回该字符的ASCII码值<br>但不使用缓冲区，直接从键盘获取，不用按回车，即输即取<br>不会回显</p>
</blockquote>
<p>int getche(void)</p>
<blockquote>
<p>和getch的唯一区别是getche会回显<br>我猜最后那个e是echo的缩写？</p>
</blockquote>
<h1 id="-2"><a href="#-2" class="headerlink" title="&lt;string.h&gt;"></a>&lt;string.h&gt;</h1><blockquote>
<p>&lt;string.h&gt;是C标准库中的头文件<br>而<string>是C++里面的<br>所以和string类型不相关</string></p>
</blockquote>
<p>size_t  无符号整数类型，用于作为某些库函数的返回值的数据类型</p>
<blockquote>
<p>我实在不明白为什么不直接用unsigned int呢</p>
</blockquote>
<p>NULL 空指针常量的值</p>
<blockquote>
<p>没有包含这个库文件的时候不能直接用</p>
</blockquote>
<p>size_t strlen ( const char* str )<br>返回字符串str的长度，不包括 ‘&#x2F;0’</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">50</span>] = <span class="string">&quot;hello&quot;</span> ， str2[ ] = <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;%d %d %d %d&quot;</span> , <span class="built_in">sizeof</span>( str ) , <span class="built_in">strlen</span>( str ) , <span class="built_in">sizeof</span>( str2 ) , <span class="built_in">strlen</span>( str2 ) ) ;</span><br><span class="line"><span class="comment">//输出为：50 5 6 5</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>void* memcpy (void* str1 , const void* str2 , size_t n )<br>从 str2 指向的内存块复制 n 个字节到 str1 </p>
<blockquote>
<p>memery copy 的缩写<br>注意是字节而非字符或者其他的什么，因此通常用sizeof( )函数<br>例： memcpy( arr2 , arr1 , sizeof( arr1 ) ) ; </p>
</blockquote>
<p>void* memset( void *str , int c , size_t n )<br>将指定的值 c 复制到 str 所指向的内存块的前 n 个字节中<br>第三项可以省略，此时为复制到 str 所指向的内存块的所有字节中</p>
<blockquote>
<p>非常常用，因为懒得写for循环给数组赋值（<br>但要注意它是按字节设值的，而且还是只看二进制赋值，根本不管数组里实际是什么类型的呢（摊手）<br>所以通常只能用它赋0或者-1（-1的二进制码所有位都为1）,详细原因懒得写了（</p>
</blockquote>
<p>char* strcat( char* str1 , const char* str2 )<br>把str2指向的字符串追加到str1所指向的字符串的末尾</p>
<blockquote>
<p>仅str1字符串改变，str2字符串不会有改动</p>
</blockquote>
<p>int strcmp( const char* str1 , const char* str2 )<br>将 str1 指向的字符串和 str2 指向的字符串进行比较<br>若str1 &lt; str2，返回值&lt;0<br>若str1 &#x3D; str2，返回值&#x3D;0<br>若str1 &gt; str2，返回值&gt;0</p>
<blockquote>
<p>string compare的缩写<br>比较规则是按照字典序逐个字符比较</p>
</blockquote>
<p>下面这些应该都比较好用但我还真没用过（</p>
<p>char* strchr( const char* str , int c )<br>查找字符串str中字符c第一次出现的位置，并返回该位置<br>如果没找到，就返回 NULL</p>
<p>char* strstr( const char* str1 , const char* str2 )<br>查找字符串str1中字符串str2（不包括 ‘&#x2F;0’ ）第一次出现的位置</p>
<h1 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h1><blockquote>
<p>是C++中的标准库<br>以下的程序都默认在开头加了using namespace std;<br>否则这些函数用的时候都得在前面加个 std::</p>
</blockquote>
<p>sort( container.begin( ) , container.end( ) , compare_function )<br>对容器中的元素进行排序</p>
<blockquote>
<p>第三项用于自定义排序方式，省略时表示按数据的大小从小到大排序<br>虽说被诟病已久（）但在时间限制没有很苛刻的情况下还是相当好用的<br>何况它时间复杂度是O(NlogN)，和快排不是差不多吗，为啥oier都这么青睐快排啊（恼）</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2024/10/16/tulun/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/16/tulun/" class="post-title-link" itemprop="url">图论概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-16 22:55:29" itemprop="dateCreated datePublished" datetime="2024-10-16T22:55:29+08:00">2024-10-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-17 16:52:53" itemprop="dateModified" datetime="2024-10-17T16:52:53+08:00">2024-10-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>打算来正经地补一下图论了<br><del>其实基本都是抄自老师的ppt</del></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h4 id="一个图是一个有序二元组-（V-E）"><a href="#一个图是一个有序二元组-（V-E）" class="headerlink" title="一个图是一个有序二元组 （V,E）"></a>一个图是一个有序二元组 （V,E）</h4><p>1.V是一个有限的非空集合，称为顶点集合，用 |V| 或 v(G) 或 v 表示顶点数<br>2.E是由V中的点组成的无序对构成的集合，称为边集，其元素称为边（同一点对可以出现多次），用 |E| 或 e(G) 或 e 表示边数</p>
<h3 id="一些相关概念"><a href="#一些相关概念" class="headerlink" title="一些相关概念"></a>一些相关概念</h3><p><del>一些很简单的证明过程我就懒得写了</del></p>
<p><strong>相邻</strong>：同一条边的两个端点称为相邻<br><strong>关联</strong>：一条边的端点和边相连<br><strong>环</strong>：端点重合的边（一个环算两个边）<br><strong>重边</strong>：端点相同的边<br><strong>有限图</strong>：顶点集和边集都是有限的图<br><strong>平凡图</strong>：只有一个顶点的图<br><strong>简单图</strong>：不含重边和环的图</p>
<p><strong>顶点v的度数 d(v)</strong> :与v相关联的边的条数<br><strong>面f的度数 d(f)</strong> :与f相关联的边的条数<br><strong>最大度数</strong> $ \Delta (G)&#x3D;max { d(v)|v \in V } $<br><strong>最小度数</strong> $ \delta (G)&#x3D;min { d(v)|v \in V } $<br><strong>度和关系式</strong> $ \sum_{v \in V}d(v)&#x3D;2e $<br>（即所有点的度数之和为总边数的两倍）<br>$ \sum_{f \in F}d(f)&#x3D;2e $<br>（即所有面的度数之和为总边数的两倍）<br><strong>推论</strong>：在任何图中，奇度点（度数为奇数的点）个数为偶数</p>
<p><strong>途径</strong>：图中点边交替出现的有限序列<br><strong>迹</strong>：一条边互不相同的途径<br><strong>路</strong>：一条点互不相同的迹<br><del>虽说这几个概念不同，但平时称呼起来好像都是混着用的</del><br><strong>Euler迹</strong>：经过图的每一条边的迹<br><strong>Euler环游&#x2F;欧拉回路</strong>：闭（起点和终点一样）的Euler迹<br><strong>Euler通路&#x2F;欧拉路径</strong>：开（起点和终点不同）的Euler迹<br><strong>Euler圈</strong>：存在Euler环游的图</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2024/10/15/fourcolors/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/15/fourcolors/" class="post-title-link" itemprop="url">四色定理的部分理论证明</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-10-15 22:43:57 / 修改时间：22:50:01" itemprop="dateCreated datePublished" datetime="2024-10-15T22:43:57+08:00">2024-10-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><del>在选修课上听老师讲了之后，激动地连夜写了(</del></p>
<h1 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h1><p>任何地图上的国家只需用4种颜色来填色，就能使得任何具有共同边界的两个国家颜色都不相同——这就是四色猜想的原始形式</p>
<p>从图论的角度来看，这个问题就变成了：<br>任何平面图一定是4可染的（意思是只需要4种颜色就能保证相邻的两个面颜色不一样）</p>
<h4 id="当然了，上面两条其实不完全一样，因为在实际地图中还有“飞地”这种例外，不过我们这里就不考虑了"><a href="#当然了，上面两条其实不完全一样，因为在实际地图中还有“飞地”这种例外，不过我们这里就不考虑了" class="headerlink" title="当然了，上面两条其实不完全一样，因为在实际地图中还有“飞地”这种例外，不过我们这里就不考虑了"></a>当然了，上面两条其实不完全一样，因为在实际地图中还有“飞地”这种例外，不过我们这里就不考虑了</h4><h1 id="前期证明准备"><a href="#前期证明准备" class="headerlink" title="前期证明准备"></a>前期证明准备</h1><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>令v表示点数，e表示边数，f表示面数<br>则 $ v-e+f&#x3D;2 $<br><del>详细的我以后有空再补</del></p>
<h2 id="欧拉公式的变形"><a href="#欧拉公式的变形" class="headerlink" title="欧拉公式的变形"></a>欧拉公式的变形</h2><p>$ \sum_{v \in V(G) } {(d(v)-6)} + \sum_{f \in F(G) } {(2d(f)-6)}&#x3D;-12 $</p>
<h2 id="权转移方法"><a href="#权转移方法" class="headerlink" title="权转移方法"></a>权转移方法</h2><p>例：<br>请证明每个最小度为5的平面简单图，都含有以下两种构型之一：<br>1.一条边uv，其中d(u)&#x3D;5，d(v)&#x3D;5<br>2.一条边uv，其中d(u)&#x3D;5，d(v)&#x3D;6</p>
<p>使用反证法：<br>假设存在一个最小度为5的平面简单图G，不含以上两种构型<br>令度数最小的点为u，则d(u)&#x3D;5，且与u相连的另一点v一定满足d(v)&gt;&#x3D;7<br>根据欧拉公式变形可得<br>$ \sum_{v \in V(G) } {(d(v)-6)} + \sum_{f \in F(G) } {(2d(f)-6)}&#x3D;-12 $<br>定义每一个点v的权值c(v)&#x3D;d(v)-6<br>每一个面f的权值c(f)&#x3D;2d(f)-6<br>显然，图中所有点与面的权值和恒为-12</p>
<p>既然总和恒定不变，有一个很巧妙的想法就是：<br>让点或面的权值相互转移，来“匀”一下权值<br>例如让权值很大的点把权值匀给权值小的点</p>
<p>所以我们需要定义<strong>权转移规则</strong>，<br>设点v经过权转移后的权值为c*(v)<br>面f经过权转移后的权值为c*(f)<br>则<br>$ \sum_{v \in V(G) \cup F(G) } {c^*(v)} &#x3D; \sum_{v \in V(G) \cup F(G) } {c(v)}&#x3D;-12&lt;0 $</p>
<p><del>中间过程有点长，有空再补</del></p>
<p>本例的权转移规则如下：<br>1.每个度数为5的点从它的每个邻点得到权值1&#x2F;5<br>2.每个度数至少为4的面向与其关联的每个点转移权值1&#x2F;2</p>
<p>对于5-度点：$ c^*(v)&gt;&#x3D;c(v)+5* \frac{1}{5}&#x3D;0 $</p>
<p>对于6-度点：$ c^*(v)&gt;&#x3D;c(v)&#x3D;0 $</p>
<p>对于k-度点（k&gt;&#x3D;8）：$ c^*(v)&gt;&#x3D;c(v)-k* \frac{1}{5}&gt;&#x3D;8-6-1.6&gt;0 $ </p>
<p>对于7-度点（如果它最多是5个5-度点的邻点）：$ c^*(v)&gt;&#x3D;c(v)-5*\frac{1}{5}&#x3D;0 $</p>
<p>（如果它至少是6个5-度点的邻点）：$ c^*(v)&gt;&#x3D;c(v)-7*\frac{1}{5}+\frac{1}{2}&gt;0 $</p>
<p>又由前面的假设条件可知，图中不存在3-度面<br>对于k-度面（k&gt;&#x3D;4）：$ c^*(f)&gt;&#x3D;c(f)-k* \frac{1}{2}&#x3D;1.5k-6&gt;&#x3D;0 $</p>
<p>经过上面这些讨论，你已经发现了吧？<br>图G所有点和所有面的最终权值都非负啊！<br>而我们之前不是说总权值恒为-12么，这就得出矛盾了<br>——证毕</p>
<h1 id="四色定理的证明"><a href="#四色定理的证明" class="headerlink" title="四色定理的证明"></a>四色定理的证明</h1><p>分为两部分：</p>
<h3 id="1-使用权转移方法，证明每个平面图都含有若干构型中的其中一个"><a href="#1-使用权转移方法，证明每个平面图都含有若干构型中的其中一个" class="headerlink" title="1.使用权转移方法，证明每个平面图都含有若干构型中的其中一个"></a>1.使用权转移方法，证明每个平面图都含有若干构型中的其中一个</h3><p>除了上面提到的两条边，还有很多其他的<br>比如三度点、四度点……<br>（不过这几个证明起来比上面那个简单太多）</p>
<h3 id="2-进行可约性验证，也就是轮到计算机降维打击的时候了"><a href="#2-进行可约性验证，也就是轮到计算机降维打击的时候了" class="headerlink" title="2.进行可约性验证，也就是轮到计算机降维打击的时候了"></a>2.进行<strong>可约性验证</strong>，<del>也就是轮到计算机降维打击的时候了</del></h3><p>假设四色定理不正确，那么必然存在反例（即有一个不是4-可染的平面图G），然后证明G不含有上述提及的任何一个构型，这就能够得到矛盾<br>但是这些构型的可能性实在太复杂，所以只能用计算机枚举证明<br>而且最初证明的时候连计算机都要耗时1200小时！</p>
<p>虽然过程相当曲折且不太优雅，这四色定理总归也算是得证了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2024/10/08/enigma/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/08/enigma/" class="post-title-link" itemprop="url">Enigma恩尼格玛密码机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-08 16:48:33" itemprop="dateCreated datePublished" datetime="2024-10-08T16:48:33+08:00">2024-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-16 22:05:00" itemprop="dateModified" datetime="2024-10-16T22:05:00+08:00">2024-10-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://pic.imgdb.cn/item/67078cc2d29ded1a8c974da5.webp" alt="Enigma"></p>
<p>这张照片上像是打字机一样的机器，它的名字叫 Enigma，音译过来就是恩尼格玛<br>它可不止能够打字，<del>虽然我标题已经写出来了但还是得再说一遍</del>，它是一台用于加密与解密的密码机！<br>（打字机的出现比它早不少，合理推测这就是以打字机为灵感发明出来的……？）</p>
<p>在它诞生的年代——20世纪初，那是个战火纷飞的年代，可没有什么计算机，Enigma是纯靠机械和电气（或许还有人力）完成数据的加密与解密的，让我叹服！</p>
<p>不过更让人佩服的却是它的那群可敬的“敌人”……</p>
<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>谈起二战欧洲战场中的解码英雄，人人都知道，大名鼎鼎的人工智能之父——艾伦·图灵</p>
<p>但，这个故事的主角是另一群人，他们来自芬兰。<br>有句话说得很精妙：“在密码分析领域，恐惧乃成功之母。”<br>芬兰作为一个在德国和苏联俩大国之间夹缝求生的小国，因为对战争的恐惧，不得不去硬着头皮，千方百计地试图获取信息，于是接下了一个烫手山芋——破解德军的Enigma。</p>
<p>彼时，由于法国和波兰之间的军事合作协议，波兰人从法国那得到了不少关于Enigma的情报——法国人认为它太难破解，并且觉得德国不会有什么大动作，于是松懈下来把情报都交给波兰了。而这正合波兰的意。</p>
<p>情报如下：Enigma机的操作指南、德军编码的具体规定、商用Enigma机一台、军用Enigma内部结构的详细描述</p>
<p>看起来相当详尽，几乎都可以复现对方加密的全过程了，这解起来还不简单吗？<br>那这就大错特错了，因为其中最为关键的密钥还不知道呢！</p>
<p>先来看下Enigma机的结构</p>
<p><img src="https://pic.imgdb.cn/item/67078cd8d29ded1a8c976c65.png" alt="wiring"></p>
<p>从图中可以看到其中几个最核心的板块：<br><strong>Keyboard 键盘</strong><br><strong>Lightboard 灯板</strong><br><strong>Plugboard 插线板</strong><br><strong>Wheel&#x2F;Rotor 转子</strong><br><strong>Reflector 反射器</strong></p>
<p>这些板块之间由多根电线相连，当操作员按下键盘上的一个键时，电流会顺着连线七弯八拐地抵达灯板，点亮对应的那个小灯泡，而键盘和灯板上各自有26个键&#x2F;灯泡，一一对应26个字母。按下的那个键是明文时，亮起的就是密文；按下的是密文时，亮起的就是明文。也就是说，操作员并不需要了解它的内部结构，就能快速地对数据进行处理。</p>
<p>如上图，按下T后，亮起的是G，代表着对T这个字母加密后得到的密文就是G</p>
<p>这样一看，怎么感觉还是很简单？<br>但Enigma可不同于那些简单替换密码（如凯撒密码），它其实是“复试替换密码”<br>Enigma的精髓(?)就在于<strong>转子</strong>这个结构。</p>
<p>顾名思义，转子是可以转的——</p>
<p><img src="https://pic.imgdb.cn/item/6707a7d2d29ded1a8cb3c829.jpg" alt="wheel"></p>
<p>如上图，一台Enigma机中安了三个不同型号的转子，且每个转子上面都刻了26个字母，<br>操作员每按下一个键时，最右边的转子就会转一格，当它转了一周后就会带动中间的转子转一格<br>同理，当中间的转子转满一周时就会带动最左边的转子转一格<br>而对应槽之间的连线又不变，所以字母之间的对应关系就全都会改变<br>用这种方式，就做到了每按下一个键，密钥都改变一次</p>
<p>还不止呢，如上图，最下排的26个字母所在的就是插线板，可以看到它们之间有的连了线，有的没有连线，例如A和B连了线，所以按下键盘上的A时它会转到B，同理B会转到A，而没有连线的C则不会转到别的字母上去。</p>
<p>还有反射器，可以将经过了三个转子的字母加上偏移量再反射回去传到灯板上。</p>
<p>以上面那张简化后的结构图为例，<br>键盘上的T → 插线板上的K → 右转子上的U → 中间转子上的P → 左转子上的H → 反射器上的D → 左转子上的G → 中间转子上的R → 右转子上的W → 插线板上的G<br>于是，明文字母T就被加密为了字母G</p>
<p>这么复杂的过程，接收方要怎么解密呢？很简单，从上面这个过程可以看出，只要各板块之间的连线情况，以及转子的初始状态都相等，在键盘上按下G就可以直接得到明文T，毕竟字母之间都是一一对应的，解密的过程恰好是逆向的加密!</p>
<p>很显然，如果不知道各板块之间的连线情况，以及转子的初始状态，要把Enigma解出来几乎不可能。德军也确实这样相信。</p>
<h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>接到这样一个看不到曙光的任务，波兰方意识到靠传统的语言层面的解密手段是行不通的，于是决定将这项艰巨的工作交给数学家。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2024/10/03/first/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/03/first/" class="post-title-link" itemprop="url">first</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-03 19:36:00" itemprop="dateCreated datePublished" datetime="2024-10-03T19:36:00+08:00">2024-10-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-06 23:43:22" itemprop="dateModified" datetime="2024-10-06T23:43:22+08:00">2024-10-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>My first blog on this website!<br>弄了大半天终于把网站建好了qwq<br>算是一个新的开始吧！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2024/09/11/crypto/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/11/crypto/" class="post-title-link" itemprop="url">密码学初识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-11 15:54:40" itemprop="dateCreated datePublished" datetime="2024-09-11T15:54:40+08:00">2024-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-28 08:36:12" itemprop="dateModified" datetime="2025-02-28T08:36:12+08:00">2025-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>现在再看之前写的东西感觉太抓马了orz<br>所以这篇就重写了</p>
<p><del>先来学点英语</del></p>
<p>Password 口令<br>也就是平时登录账号时候输入的那个密码</p>
<p>Cipher&#x2F;Cypher 密码</p>
<blockquote>
<p>这两个词好像只有美式&#x2F;英式的区别？</p>
</blockquote>
<p>Crypto 加密<br>Cryptology 密码学的统称<br>它分为<strong>Cryptography</strong> （通常所说的密码学，也是本文主要要写的东西）<br>和 <strong>Cryptanalysis</strong> （密码分析学）<br>前者研究加密，后者研究怎么破解密码，一守一攻，<br>它们相互对抗的过程中也在相互促进，可成永动机（</p>
<p>老师上课强调最多的就是 <strong>信息系统安全基本属性CIA</strong><br><strong>Confidentiality</strong> （机密性）<strong>Integrity</strong> （完整性）<strong>Avaliabilty</strong>（可用性）<br>不过他也说一般不考虑最后这个（</p>
<h2 id="密码的分类"><a href="#密码的分类" class="headerlink" title="密码的分类"></a>密码的分类</h2><p>复杂的类别我打算另开文章写</p>
<h3 id="Symmetric-Ciphers-对称加密"><a href="#Symmetric-Ciphers-对称加密" class="headerlink" title="Symmetric Ciphers  对称加密"></a>Symmetric Ciphers  对称加密</h3><p>“对称”意为加密和解密这两个过程的对称——加密和解密用同一套密钥</p>
<h4 id="Substitution-Ciphers-替换加密"><a href="#Substitution-Ciphers-替换加密" class="headerlink" title="Substitution Ciphers 替换加密"></a>Substitution Ciphers 替换加密</h4><p><strong>Caesar Cipher 凯撒密码</strong><br>最著名的移位密码</p>
<p>把各个字母往后移就加密完了，连小学生都能发明出来（</p>
<p>放两个我在学校网安宣传周活动里看到的凯撒密码：<br>1.Txkdufkvrxk<br>2.Ufafxk<br>瞪眼法对我来说太难了，所以当即写了个程序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a;cin&gt;&gt;a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;a.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;=<span class="string">&#x27;a&#x27;</span>) cout&lt;&lt;(<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+(a[i]-<span class="string">&#x27;a&#x27;</span>+i)%<span class="number">26</span>);</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;(<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span>+(a[i]-<span class="string">&#x27;A&#x27;</span>+i)%<span class="number">26</span>);</span><br><span class="line">        &#125;cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解出来是Wangxinyuan和Xidian</p>
<p><strong>Vigenere Cipher 维吉尼亚密码</strong><br>凯撒密码的进阶版</p>
<p><strong>Rotor Machines 转轮密码机</strong><br>前面提到的还处在古典密码的范畴，而这种密码将密码学带到了一个新的高度，成为古典密码与现代密码学的分界线<br>（在人们试图破解它的过程中，首次（？）使用了数学知识）</p>
<p>上世纪20年代出现了这种结合了电气和机械的加密装置<br>最早的应该是Hebern Machine？<br>最出名的肯定是 Enigma 了，详见另一篇blog</p>
<h4 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h4><p><strong>AES （Advanced Encryption Standard）高级加密标准</strong><br><strong>DES （Data Encryption Standard）数据加密标准</strong><br>（<del>真的可以取这种名字吗</del>）<br><strong>SM4</strong> 国密算法，我国特有<br>SM表示“商密”<del>，不是其他的什么东西</del></p>
<h4 id="序列密码"><a href="#序列密码" class="headerlink" title="序列密码"></a>序列密码</h4><p><strong>RC4</strong> “Rivest Cypher 4”的缩写，Rivest是它的发明者</p>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p><strong>SHA系列</strong> Secure Hash Algorithm，安全散列算法<br><strong>SM3</strong> 也是我国特有</p>
<h3 id="Asymmetric-Ciphers-非对称加密"><a href="#Asymmetric-Ciphers-非对称加密" class="headerlink" title="Asymmetric Ciphers  非对称加密"></a>Asymmetric Ciphers  非对称加密</h3><p>和对称加密相对，“非对称”指的就是加密和解密用的是不同的密钥</p>
<h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><p>典</p>
<h4 id="其他的听都没听说过（"><a href="#其他的听都没听说过（" class="headerlink" title="其他的听都没听说过（"></a>其他的听都没听说过（</h4><h2 id="密码学的发展"><a href="#密码学的发展" class="headerlink" title="密码学的发展"></a>密码学的发展</h2><p><strong>时间节点</strong>：</p>
<ul>
<li><p>远古时期（？）到1949年被划分为 <strong>古典密码时期</strong>，这个时期的密码还只停留在语言的层面上，常见的有对字符的置换、代换、轮换等等</p>
</li>
<li><p>1949后到1976年属于<strong>近代密码时期</strong>，大概是两次世界大战的缘故，密码学发展迅猛，密码破译难度大幅增加</p>
</li>
<li><p>以Diffie-Hellman协议为起始点至今，属于<strong>现代密码学时期</strong>，现在的以公钥密码为代表，面向通信以及计算<br><del>（其实我不知道什么是Diffie-Hellman）</del></p>
</li>
</ul>
<p>到了现代，密码学已经和数学分不开了，<br>为了尽可能地使密码难以被破解，一般都会将密码基于某个<strong>数学困难问题</strong><br>而 数学困难问题 就是直到目前世界上仍没有出现一个有效的解决方案的问题</p>
<p>例如<strong>大整数分解，离散对数，双线性对，格</strong>等等<br>（按我个人的理解就是都是NP类问题？）</p>
<p>其中，前两个可能会被量子算法攻破，所以都说RSA迟早会die（</p>
<h3 id="现代密码学发展分支"><a href="#现代密码学发展分支" class="headerlink" title="现代密码学发展分支"></a>现代密码学发展分支</h3><p>（水平有限，直接抄ppt了）</p>
<h4 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h4><p><strong>动机</strong>：在对称加密应用中，双方需要提前预设好相同的密钥。能不能在双方无协商好的密钥的前提下，完成保密通信？<br><strong>起源</strong>：Whitfield Diffie, Martin E. Hellman, New Directions in Cryptography, IEEE<br>Transactions on Information Theory, Vol. 22, No. 6, 1976.（图灵奖）<br><strong>能力</strong>：用户的公钥公开、私钥秘密保存，加密者采用用户的公钥对数据加密而后传输对应的密文，只有私钥的拥有者能够解密数据</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p><strong>动机</strong>：能不能模拟日常生活中的签字？<br><strong>起源</strong>：Rivest R L, Shamir A, Adleman L. A method for obtaining digital signatures and public-key<br>cryptosystems[J]. Communications of the ACM, 1978, 21(2): 120-126.（图灵奖）<br><strong>能力</strong>：用户的公钥公开、私钥秘密保存，用户采用其私钥对数据签名，任意验证者均可采用该用户公钥进行验证，确保是指定用户的签名</p>
<h4 id="秘密共享"><a href="#秘密共享" class="headerlink" title="秘密共享"></a>秘密共享</h4><h4 id="不经意传输"><a href="#不经意传输" class="headerlink" title="不经意传输"></a>不经意传输</h4><h4 id="可证明安全"><a href="#可证明安全" class="headerlink" title="可证明安全"></a>可证明安全</h4><h4 id="安全计算"><a href="#安全计算" class="headerlink" title="安全计算"></a>安全计算</h4><h4 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h4><h4 id="ORAM"><a href="#ORAM" class="headerlink" title="ORAM"></a>ORAM</h4><h2 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h2><h3 id="完善保密性"><a href="#完善保密性" class="headerlink" title="完善保密性"></a>完善保密性</h3><p>若对于 $ \forall m_0,m_1\in M(\left|m_0\right|&#x3D;\left|m_1\right| ),\forall c \in C  $<br>有 $ Pr(E(k,m_0)&#x3D;c)&#x3D;Pr(E(k,m_1)&#x3D;c) $<br>其中 $ k \in K $ 是随机的<br>则对称加密体制 ( E , D ) 是<strong>完善保密</strong>的</p>
<p><strong>攻击者获得密文，然而明文是等概率的，进而推测不出明文的信息</strong></p>
<p>设 ( E , D ) 是定义在 ( k , M , C ) 上的加密方案，如果它是完善保密的，则 $ \left| K \right| \geq \left| M \right| $</p>
<p>如果一个加密体制具有完善保密性，那么密钥数量至少要和明文数量一样多</p>
<p>但是问题来了，如果要将一个长度为M的文件发送出去，需要至少M长度的密钥K加密才能满足完善加密性，而要把这个密钥K发送给对方，又需要另外一个长度至少为M的密钥K’，而K’又需要另一个K’’……</p>
<p>这样递归下去不就子子孙孙无穷尽了吗？<br>因此，在现实中是<strong>不存在</strong>真的完善保密的方案的</p>
<p><del>上述的都是老师ppt上的东西，详细内容我之后再另写</del></p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>感觉我这篇写完都能直接当大作业交上去了（</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default-index/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yupannn</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  
  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.0/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
