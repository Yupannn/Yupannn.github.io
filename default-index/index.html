<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yupannn.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="盂盘的blog">
<meta property="og:url" content="https://yupannn.github.io/default-index/index.html">
<meta property="og:site_name" content="盂盘的blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yupannn">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://yupannn.github.io/default-index/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>盂盘的blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">盂盘的blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yupannn</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2024/11/02/clib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/11/02/clib/" class="post-title-link" itemprop="url">C和C++常用库函数（防忘）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-02 12:23:40" itemprop="dateCreated datePublished" datetime="2024-11-02T12:23:40+08:00">2024-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-22 18:30:00" itemprop="dateModified" datetime="2024-11-22T18:30:00+08:00">2024-11-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id><a href="#" class="headerlink" title="&lt;stdio.h&gt;"></a>&lt;stdio.h&gt;</h1><h2 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h2><blockquote>
<p>用C语言使用标准输入输出需要包含&lt;stdio.h&gt;<br>用C++时还可以用iostream代替</p>
</blockquote>
<p>int scanf(…)</p>
<blockquote>
<p>返回正确输入的参数的个数<br>不会死循环的循环输入，用于读取文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123; <span class="comment">//EOF: End Of File ，文件末尾会有的标志，本质是-1</span></span><br><span class="line">   ... <span class="comment">//或者把!=EOF换成==1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按Ctr+C或者Ctr+Z+Enter结束输入</p>
</blockquote>
<p>int printf(…)</p>
<blockquote>
<p>返回打印字符（包括不可见的字符如空格和换行符）的个数，<br>如果有输入错误则返回一个负值</p>
</blockquote>
<h3 id="常用格式占位符"><a href="#常用格式占位符" class="headerlink" title="常用格式占位符"></a>常用格式占位符</h3><p>%d 整数<br>%ld 长整型<br>%f 浮点数<br>%lf 双精度double类型浮点数<br>%e 用科学计数法表示的浮点数，指数部分的e小写<br>%E 用科学计数法表示的浮点数，指数部分的E大写 </p>
<blockquote>
<p>默认情况（没有指定输出宽度时）下小数点后输出6位，指数占4位<br>例：printf(“%e”,123.456);<br>输出”1.234560e+02”</p>
</blockquote>
<p>%c 字符<br>%o 八进制整数<br>%x 十六进制整数<br>%u 无符号十进制整数<br>%p 指针<br>%s 字符串</p>
<blockquote>
<p>使用字符指针给定字符串的初始位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> q[n];</span><br><span class="line"><span class="type">char</span>* p=q;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,&amp;q[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//这三个printf 等价</span></span><br></pre></td></tr></table></figure>
<p>使用scanf时从初始位置一直读取，读到空字符null（’\0’）或者空白字符时结束<br>（读取后不存入数据且仍留在缓冲区里）</p>
<blockquote>
<p>空字符(Null character)是ASCII码为0的字符，缩写为NUL，通常作为结束符出现，也可以写作\0<br>输入字符串时scanf自动在末尾加上\0<br>另：NUL和NULL不是一个意思，虽然它们值都等于0，但前者表示’\0’这个字符常量，后者表示一个值为0的空指针，且定义NULL的头文件是另一个，而NUL没有被定义，所以不能直接用</p>
</blockquote>
<p>因此它不适用于包含空格或换行符制表符的字符串输入</p>
</blockquote>
<h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p><strong>右对齐</strong>  在%后加数字最小宽度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,<span class="number">2</span>);<span class="comment">//输出&quot;_2&quot;，用空格补齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02d&quot;</span>,<span class="number">2</span>);<span class="comment">//输出&quot;02&quot;，用0补齐</span></span><br></pre></td></tr></table></figure>
<p>如果要打印的位数小于最小宽度，则在前面补足；如果大于最小宽度，则打印所有的数字，不会截断<br><strong>左对齐</strong> 类似于右对齐，只是在%后还要加-</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-2d&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//输出为 &quot;2_&quot; （2后面加了1个空格，好像不能用0补齐？）</span></span><br></pre></td></tr></table></figure>

<p>对于浮点数，上述两种表示方法都会让它在最后一位后面补零，使总长度（包括小数点）不小于最小宽度<br>但补零一般都用”.”来控制小数部分位数<br>例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%8lf&quot;</span>,<span class="number">0.345</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-8lf&quot;</span>,<span class="number">0.345</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.8lf&quot;</span>,<span class="number">0.345</span>);</span><br><span class="line"><span class="comment">//前两行都输出 &quot;0.345000&quot;</span></span><br><span class="line"><span class="comment">//第三行输出 &quot;0.34500000&quot;</span></span><br></pre></td></tr></table></figure>
<p>对于字符串，”.”的用法和整数的”-“相似<br>还多了一个”*”的用法<br>例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%*s&quot;</span>,<span class="number">4</span>,<span class="string">&quot;abc&quot;</span>); <span class="comment">//至少输出4个字符，如果少于则在左边补空格，这里输出&quot;_abc&quot;（_表示空格）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.*s&quot;</span>,<span class="number">2</span>,<span class="string">&quot;abc&quot;</span>); <span class="comment">//最多输出2个字符，超出的部分会截断，这里输出&quot;ab&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%*.*s&quot;</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="string">&quot;abc&quot;</span>); <span class="comment">//第一个*表示总共至少输出5个字符，第二个*表示总共最多输出所给字符串的2个字符</span></span><br><span class="line"><span class="comment">//混合的结果就是输出&quot;___ab&quot;，在ab前面补了三个空格</span></span><br></pre></td></tr></table></figure>


<h3 id="常用转义字符"><a href="#常用转义字符" class="headerlink" title="常用转义字符"></a>常用转义字符</h3><p>%% “%”<br>\n 换行<br>\r 回车，将当前位置移到本行开头<br>\t 水平制表符（&#x3D;tab键）<br>\ “&quot;<br>&#39; “‘“<br>&quot; “””<br>\0 空字符NUL<br>\a 响铃 </p>
<hr>
<p>char* gets()</p>
<blockquote>
<p>读取一行字符串，只会在遇到\n时才停止，<br>因为它不检查输入字符的个数，容易造成溢出等问题，所以早就被ban了</p>
</blockquote>
<p>int puts(char* s)</p>
<blockquote>
<p>虽然gets不能用了，但puts还活得好好的<br>只能输出一行，并且会在字符串后自动添加换行符<br>返回值为字符串长度（包括末尾的\0），如果发生错误则返回EOF</p>
</blockquote>
<p>int getchar(void)</p>
<blockquote>
<p>只读取缓存区的一个字符，返回值为该字符的ASCII码值，读取失败时返回EOF<br>接受空格符和换行符，所以有时可能误读了前面残留的\n，这时就得提前清空缓存区</p>
</blockquote>
<p>int putchar(char c)</p>
<blockquote>
<p>返回值为该字符的ASCII码值</p>
</blockquote>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><blockquote>
<p>FILE 是一种数据类型，是预定义的一个struct，用于管理文件流<br>常见的有stdin,stdout,stderr等<br>FILE* 是指向FILE类型数据的指针</p>
</blockquote>
<p>FILE* freopen(const char* path,const char* mode,FILE* stream)</p>
<blockquote>
<p>把原先的标准流文件（stdin（默认为键盘）,stdout（默认为屏幕）,stderr（默认为屏幕））<br>重定向到由path指定的文件中<br>返回值为path所指定文件的指针，若重定向失败则返回NULL（空指针，0）</p>
</blockquote>
<p><strong>mode模式：</strong><br>“r” read，只读，文件必须存在<br>“w” write，创建一个只能写入的空文件，若文件名已存在，则删除原有文件的内容<br>“a” append，追加，若文件不存在则创建文件<br>“r+”    打开一个已存在的文件，可读也可写<br>“w+”    创建一个用于读写的空文件<br>“a+”    读取+追加</p>
<p>int fclose(FILE* stream);</p>
<blockquote>
<p>关闭stream流，如果成功则返回0，如果失败则返回EOF（-1）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;file1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="comment">//将输入重定向到file1这个文件，从file1中读取数据</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="comment">//将输出重定向到file2这个文件中，将数据输出到file2中</span></span><br><span class="line"><span class="built_in">fclose</span>(stdin);<span class="comment">//关闭重定向输入</span></span><br><span class="line"><span class="built_in">fclose</span>(stdout);<span class="comment">//关闭重定向输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者这样写</span></span><br><span class="line">FILE* f1,f2;</span><br><span class="line">f1=<span class="built_in">freopen</span>(<span class="string">&quot;file1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">f2=<span class="built_in">freopen</span>(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="built_in">fclose</span>(f1);</span><br><span class="line"><span class="built_in">fclose</span>(f2);</span><br></pre></td></tr></table></figure>

<h1 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a>iostream</h1><blockquote>
<p>不知道为什么在iostream两边加上&lt;&gt;，网站上它就显示不出来了……</p>
</blockquote>
<blockquote>
<p>是C++的标准库而不是C的<br>要加 using namespace std;</p>
</blockquote>
<p>cin&gt;&gt;</p>
<blockquote>
<p>读到空白字符就停止输入，且既不读入也不在缓冲区清除该空白字符<br>特殊地，如果还没读入数据就遇到空白字符，则忽略并清除它们，然后继续读取</p>
</blockquote>
<p>cin.getline(char* s,int n,char c)</p>
<blockquote>
<p>只读一行，读取到换行符后就结束<br>（不将换行符读入数据，但会在缓冲区中清除掉这个换行符）<br>s表示接收字符串的变量<br>n表示字符个数（超出时会截断）<br>c可写可不写，表示（在一行内）遇到c就结束输入，省略情况下默认为’\0’</p>
</blockquote>
<p>getline(cin,string s)</p>
<blockquote>
<p>搭配另一个头文件&lt;string.h&gt;使用<br>和上面那个读取方式类似<br>可以用它读取带空格的一整行</p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>sizeof ( ) 返回在内存中所占的存储空间，单位是字节 byte</p>
<blockquote>
<p>是单目运算符，不是函数哦</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span> ; <span class="type">double</span> b = <span class="number">1</span> ;</span><br><span class="line"><span class="type">int</span> arr [ ] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> &#125;</span><br><span class="line"><span class="type">char</span> str [ ] = <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span> , <span class="built_in">sizeof</span>(a), <span class="built_in">sizeof</span>(b), <span class="built_in">sizeof</span>(arr), <span class="built_in">sizeof</span>(str) );</span><br><span class="line"><span class="comment">//输出为 : 4 8 12 6</span></span><br><span class="line"><span class="comment">//计算数组存储空间时：3（元素个数；int类型数据数量）*4（每个int类型数据所占字节）=12</span></span><br><span class="line"><span class="comment">//计算字符串时：5+1（使用“ ”表示字符串时会自动在最后面加上 &#x27;\0&#x27;（或者说是NULL））=6</span></span><br></pre></td></tr></table></figure>
<p>返回值类型为 size_t 类型，好像新标准以来就得用%zd不能用%d了……？<br>在不同的机器上它实际上的类型可能各不相同<br>总之用%d没问题的话就用%d，否则就试试%zd或者%lu<br>对结构体使用sizeof的过程意外地很复杂<br>涉及到一点硬件方面的东西<br>就结果而言，返回的是和你手算加出来的那个数最接近的结构体中最长字段长度的整数倍</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">a</span>&#123;</span><br><span class="line">       <span class="type">char</span> x ; <span class="comment">//sizeof( x )  为1</span></span><br><span class="line">       <span class="type">short</span> y ; <span class="comment">//sizeof( y ) 为2</span></span><br><span class="line">       <span class="type">int</span> z ; <span class="comment">//sizeof( z ) 为4</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//sizeof( a )返回的是8，不是7</span></span><br><span class="line"><span class="comment">//算出的是7，而结构体中最长字段为（int）4，所以结果为最接近的4的整数倍，8</span></span><br></pre></td></tr></table></figure>
<p>这就是字节对齐，更详细的我暂时懒得深究了orz</p>
</blockquote>
<h1 id="-1"><a href="#-1" class="headerlink" title="&lt;conio.h&gt;"></a>&lt;conio.h&gt;</h1><p>int getch(void)</p>
<blockquote>
<p>和getchar类似，只读单个字符，并返回该字符的ASCII码值<br>但不使用缓冲区，直接从键盘获取，不用按回车，即输即取<br>不会回显</p>
</blockquote>
<p>int getche(void)</p>
<blockquote>
<p>和getch的唯一区别是getche会回显<br>我猜最后那个e是echo的缩写？</p>
</blockquote>
<h1 id="-2"><a href="#-2" class="headerlink" title="&lt;string.h&gt;"></a>&lt;string.h&gt;</h1><blockquote>
<p>&lt;string.h&gt;是C标准库中的头文件<br>而<string>是C++里面的<br>所以和string类型不相关</string></p>
</blockquote>
<p>size_t  无符号整数类型，用于作为某些库函数的返回值的数据类型</p>
<blockquote>
<p>我实在不明白为什么不直接用unsigned int呢</p>
</blockquote>
<p>NULL 空指针常量的值</p>
<blockquote>
<p>没有包含这个库文件的时候不能直接用</p>
</blockquote>
<p>size_t strlen ( const char* str )<br>返回字符串str的长度，不包括 ‘&#x2F;0’</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">50</span>] = <span class="string">&quot;hello&quot;</span> ， str2[ ] = <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;%d %d %d %d&quot;</span> , <span class="built_in">sizeof</span>( str ) , <span class="built_in">strlen</span>( str ) , <span class="built_in">sizeof</span>( str2 ) , <span class="built_in">strlen</span>( str2 ) ) ;</span><br><span class="line"><span class="comment">//输出为：50 5 6 5</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>void* memcpy (void* str1 , const void* str2 , size_t n )<br>从 str2 指向的内存块复制 n 个字节到 str1 </p>
<blockquote>
<p>memery copy 的缩写<br>注意是字节而非字符或者其他的什么，因此通常用sizeof( )函数<br>例： memcpy( arr2 , arr1 , sizeof( arr1 ) ) ; </p>
</blockquote>
<p>void* memset( void *str , int c , size_t n )<br>将指定的值 c 复制到 str 所指向的内存块的前 n 个字节中<br>第三项可以省略，此时为复制到 str 所指向的内存块的所有字节中</p>
<blockquote>
<p>非常常用，因为懒得写for循环给数组赋值（<br>但要注意它是按字节设值的，而且还是只看二进制赋值，根本不管数组里实际是什么类型的呢（摊手）<br>所以通常只能用它赋0或者-1（-1的二进制码所有位都为1）,详细原因懒得写了（</p>
</blockquote>
<p>char* strcat( char* str1 , const char* str2 )<br>把str2指向的字符串追加到str1所指向的字符串的末尾</p>
<blockquote>
<p>仅str1字符串改变，str2字符串不会有改动</p>
</blockquote>
<p>int strcmp( const char* str1 , const char* str2 )<br>将 str1 指向的字符串和 str2 指向的字符串进行比较<br>若str1 &lt; str2，返回值&lt;0<br>若str1 &#x3D; str2，返回值&#x3D;0<br>若str1 &gt; str2，返回值&gt;0</p>
<blockquote>
<p>string compare的缩写<br>比较规则是按照字典序逐个字符比较</p>
</blockquote>
<p>下面这些应该都比较好用但我还真没用过（</p>
<p>char* strchr( const char* str , int c )<br>查找字符串str中字符c第一次出现的位置，并返回该位置<br>如果没找到，就返回 NULL</p>
<p>char* strstr( const char* str1 , const char* str2 )<br>查找字符串str1中字符串str2（不包括 ‘&#x2F;0’ ）第一次出现的位置</p>
<h1 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h1><blockquote>
<p>是C++中的标准库<br>以下的程序都默认在开头加了using namespace std;<br>否则这些函数用的时候都得在前面加个 std::</p>
</blockquote>
<p>sort( container.begin( ) , container.end( ) , compare_function )<br>对容器中的元素进行排序</p>
<blockquote>
<p>第三项用于自定义排序方式，省略时表示按数据的大小从小到大排序<br>虽说被诟病已久（）但在时间限制没有很苛刻的情况下还是相当好用的<br>何况它时间复杂度是O(NlogN)，和快排不是差不多吗，为啥oier都这么青睐快排啊（恼）</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2024/10/16/tulun/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/16/tulun/" class="post-title-link" itemprop="url">图论概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-16 22:55:29" itemprop="dateCreated datePublished" datetime="2024-10-16T22:55:29+08:00">2024-10-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-17 16:52:53" itemprop="dateModified" datetime="2024-10-17T16:52:53+08:00">2024-10-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>打算来正经地补一下图论了<br><del>其实基本都是抄自老师的ppt</del></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h4 id="一个图是一个有序二元组-（V-E）"><a href="#一个图是一个有序二元组-（V-E）" class="headerlink" title="一个图是一个有序二元组 （V,E）"></a>一个图是一个有序二元组 （V,E）</h4><p>1.V是一个有限的非空集合，称为顶点集合，用 |V| 或 v(G) 或 v 表示顶点数<br>2.E是由V中的点组成的无序对构成的集合，称为边集，其元素称为边（同一点对可以出现多次），用 |E| 或 e(G) 或 e 表示边数</p>
<h3 id="一些相关概念"><a href="#一些相关概念" class="headerlink" title="一些相关概念"></a>一些相关概念</h3><p><del>一些很简单的证明过程我就懒得写了</del></p>
<p><strong>相邻</strong>：同一条边的两个端点称为相邻<br><strong>关联</strong>：一条边的端点和边相连<br><strong>环</strong>：端点重合的边（一个环算两个边）<br><strong>重边</strong>：端点相同的边<br><strong>有限图</strong>：顶点集和边集都是有限的图<br><strong>平凡图</strong>：只有一个顶点的图<br><strong>简单图</strong>：不含重边和环的图</p>
<p><strong>顶点v的度数 d(v)</strong> :与v相关联的边的条数<br><strong>面f的度数 d(f)</strong> :与f相关联的边的条数<br><strong>最大度数</strong> $ \Delta (G)&#x3D;max { d(v)|v \in V } $<br><strong>最小度数</strong> $ \delta (G)&#x3D;min { d(v)|v \in V } $<br><strong>度和关系式</strong> $ \sum_{v \in V}d(v)&#x3D;2e $<br>（即所有点的度数之和为总边数的两倍）<br>$ \sum_{f \in F}d(f)&#x3D;2e $<br>（即所有面的度数之和为总边数的两倍）<br><strong>推论</strong>：在任何图中，奇度点（度数为奇数的点）个数为偶数</p>
<p><strong>途径</strong>：图中点边交替出现的有限序列<br><strong>迹</strong>：一条边互不相同的途径<br><strong>路</strong>：一条点互不相同的迹<br><del>虽说这几个概念不同，但平时称呼起来好像都是混着用的</del><br><strong>Euler迹</strong>：经过图的每一条边的迹<br><strong>Euler环游&#x2F;欧拉回路</strong>：闭（起点和终点一样）的Euler迹<br><strong>Euler通路&#x2F;欧拉路径</strong>：开（起点和终点不同）的Euler迹<br><strong>Euler圈</strong>：存在Euler环游的图</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2024/10/15/fourcolors/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/15/fourcolors/" class="post-title-link" itemprop="url">四色定理的部分理论证明</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-10-15 22:43:57 / 修改时间：22:50:01" itemprop="dateCreated datePublished" datetime="2024-10-15T22:43:57+08:00">2024-10-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><del>在选修课上听老师讲了之后，激动地连夜写了(</del></p>
<h1 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h1><p>任何地图上的国家只需用4种颜色来填色，就能使得任何具有共同边界的两个国家颜色都不相同——这就是四色猜想的原始形式</p>
<p>从图论的角度来看，这个问题就变成了：<br>任何平面图一定是4可染的（意思是只需要4种颜色就能保证相邻的两个面颜色不一样）</p>
<h4 id="当然了，上面两条其实不完全一样，因为在实际地图中还有“飞地”这种例外，不过我们这里就不考虑了"><a href="#当然了，上面两条其实不完全一样，因为在实际地图中还有“飞地”这种例外，不过我们这里就不考虑了" class="headerlink" title="当然了，上面两条其实不完全一样，因为在实际地图中还有“飞地”这种例外，不过我们这里就不考虑了"></a>当然了，上面两条其实不完全一样，因为在实际地图中还有“飞地”这种例外，不过我们这里就不考虑了</h4><h1 id="前期证明准备"><a href="#前期证明准备" class="headerlink" title="前期证明准备"></a>前期证明准备</h1><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>令v表示点数，e表示边数，f表示面数<br>则 $ v-e+f&#x3D;2 $<br><del>详细的我以后有空再补</del></p>
<h2 id="欧拉公式的变形"><a href="#欧拉公式的变形" class="headerlink" title="欧拉公式的变形"></a>欧拉公式的变形</h2><p>$ \sum_{v \in V(G) } {(d(v)-6)} + \sum_{f \in F(G) } {(2d(f)-6)}&#x3D;-12 $</p>
<h2 id="权转移方法"><a href="#权转移方法" class="headerlink" title="权转移方法"></a>权转移方法</h2><p>例：<br>请证明每个最小度为5的平面简单图，都含有以下两种构型之一：<br>1.一条边uv，其中d(u)&#x3D;5，d(v)&#x3D;5<br>2.一条边uv，其中d(u)&#x3D;5，d(v)&#x3D;6</p>
<p>使用反证法：<br>假设存在一个最小度为5的平面简单图G，不含以上两种构型<br>令度数最小的点为u，则d(u)&#x3D;5，且与u相连的另一点v一定满足d(v)&gt;&#x3D;7<br>根据欧拉公式变形可得<br>$ \sum_{v \in V(G) } {(d(v)-6)} + \sum_{f \in F(G) } {(2d(f)-6)}&#x3D;-12 $<br>定义每一个点v的权值c(v)&#x3D;d(v)-6<br>每一个面f的权值c(f)&#x3D;2d(f)-6<br>显然，图中所有点与面的权值和恒为-12</p>
<p>既然总和恒定不变，有一个很巧妙的想法就是：<br>让点或面的权值相互转移，来“匀”一下权值<br>例如让权值很大的点把权值匀给权值小的点</p>
<p>所以我们需要定义<strong>权转移规则</strong>，<br>设点v经过权转移后的权值为c*(v)<br>面f经过权转移后的权值为c*(f)<br>则<br>$ \sum_{v \in V(G) \cup F(G) } {c^*(v)} &#x3D; \sum_{v \in V(G) \cup F(G) } {c(v)}&#x3D;-12&lt;0 $</p>
<p><del>中间过程有点长，有空再补</del></p>
<p>本例的权转移规则如下：<br>1.每个度数为5的点从它的每个邻点得到权值1&#x2F;5<br>2.每个度数至少为4的面向与其关联的每个点转移权值1&#x2F;2</p>
<p>对于5-度点：$ c^*(v)&gt;&#x3D;c(v)+5* \frac{1}{5}&#x3D;0 $</p>
<p>对于6-度点：$ c^*(v)&gt;&#x3D;c(v)&#x3D;0 $</p>
<p>对于k-度点（k&gt;&#x3D;8）：$ c^*(v)&gt;&#x3D;c(v)-k* \frac{1}{5}&gt;&#x3D;8-6-1.6&gt;0 $ </p>
<p>对于7-度点（如果它最多是5个5-度点的邻点）：$ c^*(v)&gt;&#x3D;c(v)-5*\frac{1}{5}&#x3D;0 $</p>
<p>（如果它至少是6个5-度点的邻点）：$ c^*(v)&gt;&#x3D;c(v)-7*\frac{1}{5}+\frac{1}{2}&gt;0 $</p>
<p>又由前面的假设条件可知，图中不存在3-度面<br>对于k-度面（k&gt;&#x3D;4）：$ c^*(f)&gt;&#x3D;c(f)-k* \frac{1}{2}&#x3D;1.5k-6&gt;&#x3D;0 $</p>
<p>经过上面这些讨论，你已经发现了吧？<br>图G所有点和所有面的最终权值都非负啊！<br>而我们之前不是说总权值恒为-12么，这就得出矛盾了<br>——证毕</p>
<h1 id="四色定理的证明"><a href="#四色定理的证明" class="headerlink" title="四色定理的证明"></a>四色定理的证明</h1><p>分为两部分：</p>
<h3 id="1-使用权转移方法，证明每个平面图都含有若干构型中的其中一个"><a href="#1-使用权转移方法，证明每个平面图都含有若干构型中的其中一个" class="headerlink" title="1.使用权转移方法，证明每个平面图都含有若干构型中的其中一个"></a>1.使用权转移方法，证明每个平面图都含有若干构型中的其中一个</h3><p>除了上面提到的两条边，还有很多其他的<br>比如三度点、四度点……<br>（不过这几个证明起来比上面那个简单太多）</p>
<h3 id="2-进行可约性验证，也就是轮到计算机降维打击的时候了"><a href="#2-进行可约性验证，也就是轮到计算机降维打击的时候了" class="headerlink" title="2.进行可约性验证，也就是轮到计算机降维打击的时候了"></a>2.进行<strong>可约性验证</strong>，<del>也就是轮到计算机降维打击的时候了</del></h3><p>假设四色定理不正确，那么必然存在反例（即有一个不是4-可染的平面图G），然后证明G不含有上述提及的任何一个构型，这就能够得到矛盾<br>但是这些构型的可能性实在太复杂，所以只能用计算机枚举证明<br>而且最初证明的时候连计算机都要耗时1200小时！</p>
<p>虽然过程相当曲折且不太优雅，这四色定理总归也算是得证了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2024/10/08/enigma/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/08/enigma/" class="post-title-link" itemprop="url">Enigma恩尼格玛密码机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-08 16:48:33" itemprop="dateCreated datePublished" datetime="2024-10-08T16:48:33+08:00">2024-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-16 22:05:00" itemprop="dateModified" datetime="2024-10-16T22:05:00+08:00">2024-10-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://pic.imgdb.cn/item/67078cc2d29ded1a8c974da5.webp" alt="Enigma"></p>
<p>这张照片上像是打字机一样的机器，它的名字叫 Enigma，音译过来就是恩尼格玛<br>它可不止能够打字，<del>虽然我标题已经写出来了但还是得再说一遍</del>，它是一台用于加密与解密的密码机！<br>（打字机的出现比它早不少，合理推测这就是以打字机为灵感发明出来的……？）</p>
<p>在它诞生的年代——20世纪初，那是个战火纷飞的年代，可没有什么计算机，Enigma是纯靠机械和电气（或许还有人力）完成数据的加密与解密的，让我叹服！</p>
<p>不过更让人佩服的却是它的那群可敬的“敌人”……</p>
<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>谈起二战欧洲战场中的解码英雄，人人都知道，大名鼎鼎的人工智能之父——艾伦·图灵</p>
<p>但，这个故事的主角是另一群人，他们来自芬兰。<br>有句话说得很精妙：“在密码分析领域，恐惧乃成功之母。”<br>芬兰作为一个在德国和苏联俩大国之间夹缝求生的小国，因为对战争的恐惧，不得不去硬着头皮，千方百计地试图获取信息，于是接下了一个烫手山芋——破解德军的Enigma。</p>
<p>彼时，由于法国和波兰之间的军事合作协议，波兰人从法国那得到了不少关于Enigma的情报——法国人认为它太难破解，并且觉得德国不会有什么大动作，于是松懈下来把情报都交给波兰了。而这正合波兰的意。</p>
<p>情报如下：Enigma机的操作指南、德军编码的具体规定、商用Enigma机一台、军用Enigma内部结构的详细描述</p>
<p>看起来相当详尽，几乎都可以复现对方加密的全过程了，这解起来还不简单吗？<br>那这就大错特错了，因为其中最为关键的密钥还不知道呢！</p>
<p>先来看下Enigma机的结构</p>
<p><img src="https://pic.imgdb.cn/item/67078cd8d29ded1a8c976c65.png" alt="wiring"></p>
<p>从图中可以看到其中几个最核心的板块：<br><strong>Keyboard 键盘</strong><br><strong>Lightboard 灯板</strong><br><strong>Plugboard 插线板</strong><br><strong>Wheel&#x2F;Rotor 转子</strong><br><strong>Reflector 反射器</strong></p>
<p>这些板块之间由多根电线相连，当操作员按下键盘上的一个键时，电流会顺着连线七弯八拐地抵达灯板，点亮对应的那个小灯泡，而键盘和灯板上各自有26个键&#x2F;灯泡，一一对应26个字母。按下的那个键是明文时，亮起的就是密文；按下的是密文时，亮起的就是明文。也就是说，操作员并不需要了解它的内部结构，就能快速地对数据进行处理。</p>
<p>如上图，按下T后，亮起的是G，代表着对T这个字母加密后得到的密文就是G</p>
<p>这样一看，怎么感觉还是很简单？<br>但Enigma可不同于那些简单替换密码（如凯撒密码），它其实是“复试替换密码”<br>Enigma的精髓(?)就在于<strong>转子</strong>这个结构。</p>
<p>顾名思义，转子是可以转的——</p>
<p><img src="https://pic.imgdb.cn/item/6707a7d2d29ded1a8cb3c829.jpg" alt="wheel"></p>
<p>如上图，一台Enigma机中安了三个不同型号的转子，且每个转子上面都刻了26个字母，<br>操作员每按下一个键时，最右边的转子就会转一格，当它转了一周后就会带动中间的转子转一格<br>同理，当中间的转子转满一周时就会带动最左边的转子转一格<br>而对应槽之间的连线又不变，所以字母之间的对应关系就全都会改变<br>用这种方式，就做到了每按下一个键，密钥都改变一次</p>
<p>还不止呢，如上图，最下排的26个字母所在的就是插线板，可以看到它们之间有的连了线，有的没有连线，例如A和B连了线，所以按下键盘上的A时它会转到B，同理B会转到A，而没有连线的C则不会转到别的字母上去。</p>
<p>还有反射器，可以将经过了三个转子的字母加上偏移量再反射回去传到灯板上。</p>
<p>以上面那张简化后的结构图为例，<br>键盘上的T → 插线板上的K → 右转子上的U → 中间转子上的P → 左转子上的H → 反射器上的D → 左转子上的G → 中间转子上的R → 右转子上的W → 插线板上的G<br>于是，明文字母T就被加密为了字母G</p>
<p>这么复杂的过程，接收方要怎么解密呢？很简单，从上面这个过程可以看出，只要各板块之间的连线情况，以及转子的初始状态都相等，在键盘上按下G就可以直接得到明文T，毕竟字母之间都是一一对应的，解密的过程恰好是逆向的加密!</p>
<p>很显然，如果不知道各板块之间的连线情况，以及转子的初始状态，要把Enigma解出来几乎不可能。德军也确实这样相信。</p>
<h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>接到这样一个看不到曙光的任务，波兰方意识到靠传统的语言层面的解密手段是行不通的，于是决定将这项艰巨的工作交给数学家。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2024/10/03/first/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/03/first/" class="post-title-link" itemprop="url">first</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-10-03 19:36:00" itemprop="dateCreated datePublished" datetime="2024-10-03T19:36:00+08:00">2024-10-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-06 23:43:22" itemprop="dateModified" datetime="2024-10-06T23:43:22+08:00">2024-10-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>My first blog on this website!<br>弄了大半天终于把网站建好了qwq<br>算是一个新的开始吧！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2024/09/11/crypto/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/11/crypto/" class="post-title-link" itemprop="url">密码学初识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-11 15:54:40" itemprop="dateCreated datePublished" datetime="2024-09-11T15:54:40+08:00">2024-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-11-18 12:26:48" itemprop="dateModified" datetime="2024-11-18T12:26:48+08:00">2024-11-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>现在再看之前写的东西感觉太抓马了orz<br>所以这篇就重写了</p>
<p><del>先来学点英语</del></p>
<p>Password 口令<br>也就是平时登录账号时候输入的那个密码</p>
<p>Cipher&#x2F;Cypher 密码</p>
<blockquote>
<p>这两个词好像只有美式&#x2F;英式的区别？</p>
</blockquote>
<p>Crypto 加密<br>Cryptology 密码学的统称<br>它分为<strong>Cryptography</strong> （通常所说的密码学，也是本文主要要写的东西）<br>和 <strong>Cryptanalysis</strong> （密码分析学）<br>前者研究加密，后者研究怎么破解密码，一守一攻，<br>它们相互对抗的过程中也在相互促进，可成永动机（</p>
<p>老师上课强调最多的就是 <strong>信息系统安全基本属性CIA</strong><br><strong>Confidentiality</strong> （机密性）<strong>Integrity</strong> （完整性）<strong>Avaliabilty</strong>（可用性）<br>不过他也说一般不考虑最后这个（</p>
<h2 id="密码的分类"><a href="#密码的分类" class="headerlink" title="密码的分类"></a>密码的分类</h2><p>复杂的类别我打算另开文章写</p>
<h3 id="Symmetric-Ciphers-对称加密"><a href="#Symmetric-Ciphers-对称加密" class="headerlink" title="Symmetric Ciphers  对称加密"></a>Symmetric Ciphers  对称加密</h3><p>“对称”意为加密和解密这两个过程的对称——加密和解密用同一套密钥</p>
<h4 id="Substitution-Ciphers-替换加密"><a href="#Substitution-Ciphers-替换加密" class="headerlink" title="Substitution Ciphers 替换加密"></a>Substitution Ciphers 替换加密</h4><p><strong>Caesar Cipher 凯撒密码</strong><br>最著名的移位密码</p>
<p>把各个字母往后移就加密完了，连小学生都能发明出来（</p>
<p>放两个我在学校网安宣传周活动里看到的凯撒密码：<br>1.Txkdufkvrxk<br>2.Ufafxk<br>瞪眼法对我来说太难了，所以当即写了个程序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a;cin&gt;&gt;a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;a.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;=<span class="string">&#x27;a&#x27;</span>) cout&lt;&lt;(<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+(a[i]-<span class="string">&#x27;a&#x27;</span>+i)%<span class="number">26</span>);</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;(<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span>+(a[i]-<span class="string">&#x27;A&#x27;</span>+i)%<span class="number">26</span>);</span><br><span class="line">        &#125;cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解出来是Wangxinyuan和Xidian</p>
<p><strong>Vigenere Cipher 维吉尼亚密码</strong><br>凯撒密码的进阶版</p>
<p><strong>Rotor Machines 转轮密码机</strong><br>前面提到的还处在古典密码的范畴，而这种密码将密码学带到了一个新的高度，成为古典密码与现代密码学的分界线<br>（在人们试图破解它的过程中，首次（？）使用了数学知识）</p>
<p>上世纪20年代出现了这种结合了电气和机械的加密装置<br>最早的应该是Hebern Machine？<br>最出名的肯定是 Enigma 了，详见另一篇blog</p>
<h4 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h4><p><strong>AES （Advanced Encryption Standard）高级加密标准</strong><br><strong>DES （Data Encryption Standard）数据加密标准</strong><br>（<del>真的可以取这种名字吗</del>）<br><strong>SM4</strong> 国密算法，我国特有<br>SM表示“商密”<del>，不是其他的什么东西</del></p>
<h4 id="序列密码"><a href="#序列密码" class="headerlink" title="序列密码"></a>序列密码</h4><p><strong>RC4</strong> “Rivest Cypher 4”的缩写，Rivest是它的发明者</p>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p><strong>SHA系列</strong> Secure Hash Algorithm，安全散列算法<br><strong>SM3</strong> 也是我国特有</p>
<h3 id="Asymmetric-Ciphers-非对称加密"><a href="#Asymmetric-Ciphers-非对称加密" class="headerlink" title="Asymmetric Ciphers  非对称加密"></a>Asymmetric Ciphers  非对称加密</h3><p>和对称加密相对，“非对称”指的就是加密和解密用的是不同的密钥</p>
<h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><p>典</p>
<h4 id="其他的听都没听说过（"><a href="#其他的听都没听说过（" class="headerlink" title="其他的听都没听说过（"></a>其他的听都没听说过（</h4><h2 id="密码学的发展"><a href="#密码学的发展" class="headerlink" title="密码学的发展"></a>密码学的发展</h2><p><strong>时间节点</strong>：</p>
<ul>
<li><p>远古时期（？）到1949年被划分为 <strong>古典密码时期</strong>，这个时期的密码还只停留在语言的层面上，常见的有对字符的置换、代换、轮换等等</p>
</li>
<li><p>1949后到1976年属于<strong>近代密码时期</strong>，大概是两次世界大战的缘故，密码学发展迅猛，密码破译难度大幅增加</p>
</li>
<li><p>以Diffie-Hellman协议为起始点至今，属于<strong>现代密码学时期</strong>，现在的以公钥密码为代表，面向通信以及计算<br><del>（其实我不知道什么是Diffie-Hellman）</del></p>
</li>
</ul>
<p>到了现代，密码学已经和数学分不开了，<br>为了尽可能地使密码难以被破解，一般都会将密码基于某个<strong>数学困难问题</strong><br>而 数学困难问题 就是直到目前世界上仍没有出现一个有效的解决方案的问题</p>
<p>例如<strong>大整数分解，离散对数，双线性对，格</strong>等等<br>（按我个人的理解就是都是NP类问题？）</p>
<p>其中，前两个可能会被量子算法攻破，所以都说RSA迟早会die（</p>
<h3 id="现代密码学发展分支"><a href="#现代密码学发展分支" class="headerlink" title="现代密码学发展分支"></a>现代密码学发展分支</h3><p>（水平有限，直接抄ppt了）</p>
<h4 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h4><p><strong>动机</strong>：在对称加密应用中，双方需要提前预设好相同的密钥。能不能在双方无协商好的密钥的前提下，完成保密通信？<br><strong>起源</strong>：Whitfield Diffie, Martin E. Hellman, New Directions in Cryptography, IEEE<br>Transactions on Information Theory, Vol. 22, No. 6, 1976.（图灵奖）<br><strong>能力</strong>：用户的公钥公开、私钥秘密保存，加密者采用用户的公钥对数据加密而后传输对应的密文，只有私钥的拥有者能够解密数据</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p><strong>动机</strong>：能不能模拟日常生活中的签字？<br><strong>起源</strong>：Rivest R L, Shamir A, Adleman L. A method for obtaining digital signatures and public-key<br>cryptosystems[J]. Communications of the ACM, 1978, 21(2): 120-126.（图灵奖）<br><strong>能力</strong>：用户的公钥公开、私钥秘密保存，用户采用其私钥对数据签名，任意验证者均可采用该用户公钥进行验证，确保是指定用户的签名</p>
<h4 id="秘密共享"><a href="#秘密共享" class="headerlink" title="秘密共享"></a>秘密共享</h4><h4 id="不经意传输"><a href="#不经意传输" class="headerlink" title="不经意传输"></a>不经意传输</h4><h4 id="可证明安全"><a href="#可证明安全" class="headerlink" title="可证明安全"></a>可证明安全</h4><h4 id="安全计算"><a href="#安全计算" class="headerlink" title="安全计算"></a>安全计算</h4><h4 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h4><h4 id="ORAM"><a href="#ORAM" class="headerlink" title="ORAM"></a>ORAM</h4><h2 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h2><h3 id="完善保密性"><a href="#完善保密性" class="headerlink" title="完善保密性"></a>完善保密性</h3><p>若对于 $ \forall m_0,m_1\in M(\left|m_0\right|&#x3D;\left|m_1\right| ),\forall c \in C  $<br>有 $ Pr(E(k,m_0)&#x3D;c)&#x3D;Pr(E(k,m_1)&#x3D;c) $<br>其中 $ k \in K $ 是随机的<br>则对称加密体制 ( E , D ) 是<strong>完善保密</strong>的</p>
<p><strong>攻击者获得密文，然而明文是等概率的，进而推测不出明文的信息</strong></p>
<p>设 ( E , D ) 是定义在 ( k , M , C ) 上的加密方案，如果它是完善保密的，则 $ \left| K \right| \geq \left| M \right| $</p>
<p>如果一个加密体制具有完善保密性，那么密钥数量至少要和明文数量一样多</p>
<p>但是问题来了，如果要将一个长度为M的文件发送出去，需要至少M长度的密钥K加密才能满足完善加密性，而要把这个密钥K发送给对方，又需要另外一个长度至少为M的密钥K’，而K’又需要另一个K’’……</p>
<p>这样递归下去不就子子孙孙无穷尽了吗？<br>因此，在现实中是<strong>不存在</strong>真的完善保密的方案的</p>
<p><del>上述的都是老师ppt上的东西，详细内容我之后再另写</del></p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>感觉我这篇写完都能直接当大作业交上去了（</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2024/02/14/sbwebsite/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/14/sbwebsite/" class="post-title-link" itemprop="url">记——电脑盲试图建网站的曲折又sb的一个月</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-14 16:03:20" itemprop="dateCreated datePublished" datetime="2024-02-14T16:03:20+08:00">2024-02-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-06 16:07:14" itemprop="dateModified" datetime="2024-10-06T16:07:14+08:00">2024-10-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>又名——这样随意又任性的弱智高三牲是真实存在的吗</p>
<p><strong>起因</strong><br>我想建一个网站，能够和AI对话的那种，能解决学习问题的那种，能用来应付应试教育的那种……<br>至于为什么在距离高考只有一百多天距离750还有150分的时候来学，别问<br>问就是我脑袋被撞了<br>再问就是富强民主文明和谐<br>再再问就是消灭人类暴政，世界属于AI</p>
<p><strong>1</strong><br>第一个星期，还处于观望期<br>首先明确我要做的是动态网站(不然咋交互呢)，这样那些简单大众的托管网站的方法就被毙掉了<br>作为万年白嫖党，要我花巨额经费去租云服务器是需要做很久心理准备的<br>观望了一周，才战战兢兢地请示我妈<br>在数小时的反复被盘问下，我不得已招了全部计划<br>历经千辛万苦才换来直到寒假结束前都(勉强算是)自由支配的电脑时间，和一点点经费</p>
<p><strong>2</strong><br>接下来的两个星期，处于奋斗和摆烂的交替状态<br>主要是因为我太SB了。。。<br>反正遇事疯狂百度<br>本来不出一个小时就能搞定的东西非让我磨蹭老久<br>遇到的问题包括但不限于：<br>装宝塔面板出问题——＞干脆不用宝塔了，我直接学linux命令行<br>使用wordpresss卡得受不了——＞干脆不用wordpress了，我直接学html和php<br>……<br>看似放弃这些便捷的软件是下下策，实际上及时转去学那些根本的东西花的时间还少一些<br>总而言之，这两个星期让我深深地感受到自己有多么地电脑盲……<br>亏我以前还学过信竞……更智障了……<br>你敢信，一个连服务器不申请公网IP就上不了网都不知道，还在那查了好几天的DNS解析，然后发现自己连域名都还没买的人是怎么畜牲牛犊不怕虎地跑来建站的……<br>总而言之，我都不敢回想这跌宕起伏的两个星期<br>其中的第一个星期，我竟然还有雅兴记点日志:</p>
<p>DAY 0<br>一个星期都在物色服务器，差点破防了……<br>破防^1<br>瞟了一下腾讯云，“未满18周岁不能实名认证”……告辞！<br>破防^2<br>果然还是选阿里云<br>上面优惠挺多，可惜都与我无瓜<br>（学生才能享有300大洋代金卷……）<br>《论一个根正苗红的高中生没法证明自己是学生这回事》<br>凭什么只有学生证才能证明我是学生？！<br>凭什么只有大学生才有学生证？！<br>破防^3<br>内地服务器要备案，这我可以理解<br>但是禁止交互禁止评论甚至禁止博客，这？<br>算了，大不了租境外的服务器<br>再定睛一看，只有内地服务器有优惠……<br>服了，奸商<br>被拿捏得死死的<br>最后还是挑了最便宜的，￥211.38，美国硅谷，centos7.9<br>只订了一个月，因为预算时间不到一个月了……（悲）</p>
<p>DAY 1<br>（我是第一天就卡在第一关的屑）<br>远程连接什么的都还顺畅<br>但是卡在了安装宝塔面板上<br>不理解，看教程上不就是一条指令的事吗？！<br>我这咋总显示failed to connect balabala……</p>
<p>DAY 2<br>经过一个小时的努力，报错信息成功从<br>Failed to connect 变成了 network is unreachable ……<br>还是没过啊喂！<br>不过基本可以确定是服务器连不上网的问题了<br>DAY 3<br>一事无成……<br>本来想去询问客服，但是人家好像只负责销售，不负责解决问题</p>
<p>DAY 4<br>原来昨天我是找错了渠道……<br>其实是有专门解决问题的工程师客服的<br>而且速度很快！</p>
<p>爆笑了，原来是因为我压根没申请EIP<br>先前还到处搜解决方法，还以为是dns解析的问题<br>我是个菜狗！！！<br>话说怎么又还要花钱啊……qwq</p>
<p>DAY 5<br>终于，终于！！<br>能连上网了！<br>开通了弹性公网ip后果然解决了！<br>但是……这宝塔面板怎么连不上去啊<br>看来遥远的大洋彼岸还是太远了<br>信号也太慢了吧</p>
<p>DAY 6<br>折腾了一个中午后<br>我果断选择放弃宝塔面板。。。<br>转身就去安了Apache,MySQL,PHP,Wordpress</p>
<p>……所以现在变成Wordpress打不开了</p>
<p>DAY 7<br>想来是因为没有注册域名……<br>于是赶紧去注册了一个<br>优惠后一年只要￥1！！<br>找了个 examgpt.xyz<br>感觉这名不错<br>另，顺便看到隔壁 examgpt.cn 有点东西（ikun出没）</p>
<p>DAY 8<br>麻了<br>域名解析不一致<br>网站还是登不上去<br>为什么这么坎坷啊啊啊！</p>
<p><strong>3</strong><br>真正干活的一个星期(同时也是我宝贵的大半个寒假)<br>经过前面那么久的铺垫，总算是先把网站给建起来了，虽然站里还什么都没有……<br>于是终于算是进入正题，然后的任务就是如何调用AI大模型的api进行问答了<br>首先去复习(其实是预习)了一下html和php，先尝试了一下在html里调用php文件<br>这一步还算顺利，但让我最摸不着头脑的是怎么调用ai<br>对于AI大模型，我选择的是讯飞星火<br>原因无他，唯免费试用耳<br>虽然官方有调用借口的文档，还有各种形式的demo，但我咋完全看不懂……<br>又搜了几天，想抄别人的程序，但是都不成功<br>本来用php形式写的就少，抄来还不管用，而且里面根本没有文档里的鉴权什么的东西<br>看着就不靠谱<br>最后，我还是硬着头皮揣摩官方给的demo程序，慢慢地好像能明白一些了<br>这就是格物致知嘛……<br>不管怎样，在大年初二的凌晨三点半，我终于成功了，泪目啊……</p>
<p><strong>4</strong><br>验收阶段<br>怀着忐忑的心情，我把网址分享到了班级群<br>虽然反响谈不上十分热烈，不过也还可以<br>网站瑕疵还很多，还有无数想法没有实现，但我心里还是挺满足的<br>随着网站建完，寒假已经到了尾声，我心里的大石头终于落地<br>写得很仓促，因为我建完站后摆烂了两天，现在是寒假的最后一天，的傍晚……<br>何况我还有一堆寒假作业要赶……<br>反正，虽然浪费了超级多的时间，但我也想说，我不后悔！<br>这个过程给了我很多积极向上的力量吧，现在的我比起过去要更开朗自信了</p>
<p>已经不想回忆过去了<br>接下来的一百天，又是一场战役！</p>
<p>另：网站域名：examgpt.xyz<br>如果您在2024.2.22.之前拜访，就可以欣赏到我一个月做出的SB玩意儿……</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2023/09/10/qunlun/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/10/qunlun/" class="post-title-link" itemprop="url">群论无痛入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-10 19:48:05" itemprop="dateCreated datePublished" datetime="2023-09-10T19:48:05+08:00">2023-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-06 16:07:46" itemprop="dateModified" datetime="2024-10-06T16:07:46+08:00">2024-10-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><del>本蒟蒻也只能到入门的层次了</del></p>
<h2 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h2><p>什么是群？<br>我把它理解为 ： 一个运算系统<br>换句话说，一个群里面包含 ： 数 + 运算方法<br>例如，一个最好理解的群，由 整数加法 构成的一个群：<br>…… -2,-1,0,1,2,3,4 ……<br>它只包含整数，对这些整数只能进行加法运算</p>
<p>为方便表示，用 G 表示非空数集，用 · 表示运算<br>当然，不是什么数加上什么运算都能算得上是群的，不然那这个群岂不是毫无意义<br>所以对群有以下规定：</p>
<h3 id="1-封闭性"><a href="#1-封闭性" class="headerlink" title="1. 封闭性"></a>1. 封闭性</h3><p>我们既然给群定义了这么一个数集 G，那它当然要包含使用这个群时会出现的每个数<br>也就是给群划定了一个范围，不管你怎么拨弄，都不会超出这个范围<br>即若 $ a \in G,b \in G,c&#x3D;a·b $</p>
<p>那么一定有 $ c \in G $</p>
<p>拿整数加法集来试验<br>$ 1 \in Z,2 \in Z,3&#x3D;1+2 $</p>
<p>$ 3 \in Z $ ，符合</p>
<h3 id="2-结合律"><a href="#2-结合律" class="headerlink" title="2. 结合律"></a>2. 结合律</h3><p>很好理解，$ a·(b·c)&#x3D;a·b·c&#x3D;(a·b)·c $</p>
<p>例如：$ 1+(2+3)&#x3D;1+2+3&#x3D;(1+2)+3 $</p>
<p><strong>注意：</strong>不一定满足交换律, a · b 不一定等于 b · a</p>
<h3 id="3-单位元"><a href="#3-单位元" class="headerlink" title="3. 单位元"></a>3. 单位元</h3><p>正如其名，“ 单位 ” 表示它是这个群中最基础也最元老的数<br>用 e 表示<br>规定：$ e \in G,\forall a \in G,a·e&#x3D;a $<br>也就是算了等于没算的那个数<br>在整数加法中，0 就是单位元，因为任何整数加 0 都等于它们自己</p>
<p>一个群里只有一个单位元吗？<br>假设有两个单位元，e1 和 e2<br>那么 $ e_1·e_2&#x3D;e_1,e_1·e_2&#x3D;e_2,e_1&#x3D;e_2 $<br>所以只存在一个单位元</p>
<h3 id="4-逆元"><a href="#4-逆元" class="headerlink" title="4. 逆元"></a>4. 逆元</h3><p>想象一个箭头，从坐标原点出发指向外面，又有一个箭头接着前一个箭头反向连回到原点<br>（其实我就只是想说向量）<br>逆元就相当于那个反向的箭头，将一个数转回到原点（在群的概念中就是变成单位元）<br>对 A 来说，用 $ A^{-1} $ 表示 A 的逆元( 联想一下乘除法中，3的逆元就是3^(-1))</p>
<p>$ \forall A \in G,\exists A^{-1} \in G,A·A^{-1}&#x3D;e $</p>
<p>同样地，在群里对于一个数，它只有一个逆元吗？<br>假设数 A 有两个逆元 $ A^{-1}_1, A^{-1}_2 $</p>
<p>$ ( A^{-1}_1 · A ) · A^{-1}_2 &#x3D; e · A^{-1}_2 &#x3D; A^{-1}_2 , A^{-1}_1·（A· A^{-1}_2）&#x3D; e·A^{-1}_1 &#x3D; A^{-1}_1 $</p>
<p>由结合律可知 $ ( A^{-1}_1 · A ) · A^{-1}_2 &#x3D;A^{-1}_1·（A· A^{-1}_2） $</p>
<p>得到 $ A^{-1}_1 &#x3D; A^{-1}_2 $ ，所以每个数只存在唯一对应的一个逆元</p>
<p>举个栗子：整数加法中，0 是单位元，对于每个整数，它的相反数就是它的逆元<br>$ 1 \in Z,-1 \in Z,1+(-1)&#x3D;1-1&#x3D;0&#x3D;e \Rightarrow 1^{-1}&#x3D;-1, (-1)^{-1}&#x3D;1 $</p>
<p>同时也可以看出，逆元具有相互性<br>$ A^{-1}&#x3D;B \Rightarrow B^{-1}&#x3D;A $</p>
<hr>
<p>基本的性质就是这些了，已经知道群是啥了，赶紧拿着定义去套一套马，看看能套住哪一匹<br>既然 整数加法 是群，那 整数乘法 呢？</p>
<ol>
<li>封闭性： 任何两个整数乘起来也还是个整数对吧，满足！</li>
<li>结合律： a * b&#x3D;b * a ，满足！</li>
<li>单位元： 1？  1 * (-1)&#x3D;-1 ，1 * 0 &#x3D;0，1 * 2&#x3D;2 , 1* 3&#x3D;3 …… 满足！</li>
<li>逆元： 等等，找不到逆元啊？3 要乘几才能等于 1 呢？</li>
</ol>
<p>看来这么一个直截了当的整数乘法不构成群！<br>看看往数集内加入小数，即把整数集 Z 扩充成实数集 R,能使它构成群吗？</p>
<p>2 *（1&#x2F;2）&#x3D;1 , 3 *（1&#x2F;3）&#x3D;1 …… 好像满足<br>但是 0 怎么办？ 0 乘任何数都等于 0，它不存在逆元，所以为了构成群，就应该把 0 排除在外</p>
<p>综上所述，不存在整数乘法群<br>但经过修修补补，可以发现 有理数乘法（数集为 {x|$ x \ne 0,x \in R $}）可以构成群<br>同时，也可以发现 有理数乘法群 和 有理数除法群 是等价的东西！妙哉妙哉</p>
<h2 id="直面数学"><a href="#直面数学" class="headerlink" title="直面数学"></a>直面数学</h2><p>用更形式化的语言来说，（以下有部分抄自《算法导论》）<br>群$ (S,\oplus) $是一个集合 S 和一个定义在 S 上的二元运算 $ \oplus $<br>例如，加法运算下整数 Z 所构成的群表示为 $ (Z,+) $<br>由前言可知，交换律并不是一个普适的基础性质，所以特别地如果有个群满足交换律，可以叫它交换群<br>另外，如果某个群 $ (S,\oplus) $ 满足 $ |S|&lt; \infty $，则它是一个有限群</p>
<p>我们常用到的大多为模意义下的整数加法乘法</p>
<p>定义模 n 加法群为 $ (Z_n,+_n) $ , 它的规模为 $ |Z_n|&#x3D;n $<br>( |Z| 指集合 Z 内元素个数 )</p>
<p>而用它进行运算的算式可表示为 $ [a]_n +_n [b]_n &#x3D; [a+b]_n $<br>( $ +_n $ 是运算符号，代表模 n 意义下的加法，别看成 + n )<br>也即： 若 $ a \equiv a’ \pmod{n} , b \equiv b’ \pmod{n} $<br>那么 $ a+b \equiv a’+b’ \pmod{n} $<br>容易看出，这个群内的元素都不会超过 n<br>想象你站在地球赤道上的一点，一直沿着纬线向前，然后又回到了原点，这是一样的道理</p>
<p>下表为群 $ (Z_6,+_6) $ 的运算表</p>
<table>
<thead>
<tr>
<th align="center">$ +_6 $</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>很显然， $ (Z_n,+_n) $ 是有限交换群<br>单位元是0，元素 a （非0）的逆元是 $ [-a]_n &#x3D;[n-a]_n &#x3D;n-a $ ，0的逆元就是它自己</p>
<p>相似地，可以定义模 n 意义下的乘法群 $ (Z_n^*,\cdot_n) $</p>
<p>$ [a]_n \cdot_n [b]_n &#x3D;[ab]_n $</p>
<p>下表为群 $ (Z_{10}^*, \cdot_{10}) $ 的运算表</p>
<table>
<thead>
<tr>
<th align="center">$ \cdot_{10} $</th>
<th align="center">1</th>
<th align="center">3</th>
<th align="center">7</th>
<th align="center">9</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">7</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">9</td>
<td align="center">1</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">1</td>
<td align="center">9</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">9</td>
<td align="center">7</td>
<td align="center">3</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>看着这个表就能发现，$ Z_n^* $ 中的都是与n互质的数，<br>由此可以得到 $ Z_n^* $ 的阶数（即其中所含数的个数）等于在小于n的数中与n不互质的数的个数<br>有一个大名鼎鼎的函数来表示这个群的规模：</p>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>$ \phi (n) &#x3D; n \prod_{p:p是素数且p|n}(1-\frac{1}{p}) $</p>
<p>特殊地，当n是素数时， $ \phi(n)&#x3D;n(1-\frac{1}{n})&#x3D;n-1 $<br>当n&#x3D;p*q 且p和q都为素数时， $ \phi(n)&#x3D;n(1-\frac{1}{p})(1-\frac{1}{q})&#x3D;(p-1)(q-1) $</p>
<p>例：$ \phi(15)&#x3D;15(1-\frac{1}{3})(1-\frac{1}{5})&#x3D;8 $<br>即比15小的数里有8个和15互质，在 $ Z_{15}^* $ 这个群中有8个数</p>
<p><strong>证明：</strong><br>先对n进行质因数分解，得到</p>
<p>$ n&#x3D;p_1^{k_1} p_2^{k_2} ······ p_m^{k_m} $</p>
<p>其中 $ p_1,p_2······p_m $ 都是素数</p>
<p>我首先考虑的就是<strong>数学归纳法</strong></p>
<p>当n&#x3D;pq，且p和q互质时，<br>合理推测 $ \phi(n)&#x3D;\phi(p)\phi(q) $<br>事实也确实是这样</p>
<p>再去看那个质因数分解的式子，就恍然大悟啦</p>
<p>对于 $  n&#x3D;p_1^{k_1} p_2^{k_2} ······ p_m^{k_m}  $</p>
<p>假设 $ \phi(n)&#x3D;n\prod_{i&#x3D;1}^{i&lt;&#x3D;m}(1-\frac{1}{p_i}) $</p>
<p>那么对于 $ n_1&#x3D;p_mn&#x3D;p_1^{k_1} p_2^{k_2} ······ p_m^{k_m+1} $</p>
<p>想象将长度为n的长条往后延长到它的 $ p_m $ 倍</p>
<p>容易想到 $ \phi(n_1)&#x3D;p_m\phi(n)&#x3D;n_1\prod_{i&#x3D;1}^{i&lt;&#x3D;m}(1-\frac{1}{p_i}) $</p>
<p>对于 $ n_2&#x3D;p_{m+1}n&#x3D;p_1^{k_1} p_2^{k_2} ······ p_m^{k_m} p_{m+1} $</p>
<p>因为p和q互质，可以令 $ p&#x3D;n,q&#x3D;p_{m+1} $ ，这样 $ n_2 $ 也转换成pq的形式了</p>
<p>$ \phi(n_2)&#x3D;\phi(n)(q-1)&#x3D;q\phi(n)(1-\frac{1}{q})&#x3D;n_2\prod_{i&#x3D;1}^{i&lt;&#x3D;m+1}(1-\frac{1}{p_i}) $</p>
<p>像这样类推&#x2F;归纳就行了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2023/07/16/dpzhengshu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/16/dpzhengshu/" class="post-title-link" itemprop="url">【DP专题】整数划分</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-16 17:17:24" itemprop="dateCreated datePublished" datetime="2023-07-16T17:17:24+08:00">2023-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-06 17:18:59" itemprop="dateModified" datetime="2024-10-06T17:18:59+08:00">2024-10-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1.求把n划分成k个正整数的方案数？ </p>
<p>2.求把n划分成互不相同k个正整数的方案数？ </p>
<p>3.求把n划分成k个不大于m的互不相同正整数的方案数？ </p>
<p>4.求把n划分成k个奇数的方案数？</p>
<p>5.…………………………</p>
<p><del>问得我人都麻了</del></p>
<h3 id="问题1：求把n划分成k个正整数的方案数"><a href="#问题1：求把n划分成k个正整数的方案数" class="headerlink" title="问题1：求把n划分成k个正整数的方案数"></a>问题1：求把n划分成k个正整数的方案数</h3><p>脑容量告急，先来想下暴力dp</p>
<p>设dp[i][j][sum]前i个数，选了j个数，和为sum的方案数是多少</p>
<p>答案就是 dp[n][k][n]，考虑下一个数选几个来转移即可</p>
<p>状态是n<em>k</em>n，转移是 O(sum&#x2F;i)</p>
<p>均摊O(n<em>k</em>n*log(n))，复杂度有些高</p>
<p>按完全背包写的话可以做到O(n<em>k</em>n)</p>
<p>更好的写法：</p>
<p><del>妙妙屋警告</del></p>
<p>数形结合yyds</p>
<p>将i被划分成j个数的样子表示出来</p>
<p>例如：i&#x3D;22,j&#x3D;4</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/gvtxogb6.png"></p>
<p>第k列代表划分后的第k个数（保证这k个数从左到右非严格递减，这样就不会出现划分重复的情况）</p>
<p>如22&#x3D;7+6+6+3（左图）&#x3D;7+7+7+1（右图）</p>
<p>用dp[i][j]表示把i划分成j个数的方案数</p>
<p>再来想怎么进行状态转移呢？</p>
<p>从后往前想，dp[i][j]只可能是由前面的状态向下（i增加）或向右（j增加）得来</p>
<p>也就是左图和右图两种情况，蓝色部分为增加的部分</p>
<p>但光是考虑dp[i-j][j]会发现，这是只考虑了左图的情况，少算了右图（有1）的可能性</p>
<p>所以还要加上dp[i-1][j-1]</p>
<p>最终的式子：dp[i][j]&#x3D;dp[i-j][j]+dp[i-1][j-1]</p>
<p>神奇！时间复杂度只有O(N^2)</p>
<h3 id="问题2：求把n划分成互不相同k个正整数的方案数"><a href="#问题2：求把n划分成互不相同k个正整数的方案数" class="headerlink" title="问题2：求把n划分成互不相同k个正整数的方案数"></a>问题2：求把n划分成互不相同k个正整数的方案数</h3><p>和前面的大同小异</p>
<p>暴力dp的做法:</p>
<p>设dp[i][j][sum]前i个数，选了j个数，和为sum的方案数是多少</p>
<p>答案就是dp[n][k][n]，考虑下一个数选不选来转移即可</p>
<p>本质是个0&#x2F;1背包， 复杂度O(n<em>k</em>n)</p>
<p>数形结合的做法：</p>
<p>再写一遍前面推出的式子：dp[i][j]&#x3D;dp[i-j][j]+dp[i-1][j-1]</p>
<p>要限制没有相同的数字，只需要改其中一个字符就行了！</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zdyedqbc.png"></p>
<p>看着这张图应该可以猜到</p>
<p>正解是：dp[i][j]&#x3D;dp[i-j][j]+dp[i-j][j-1]</p>
<p>复杂度甚至比上题还低一点！</p>
<p>可以举反例来证明：</p>
<p>如果还用原先那个式子，不改的话，</p>
<p>dp[i-1][j-1]代表把i-1划分成j-1个互不相同的数</p>
<p>它肯定包括了“划分后最后一列数为1”的情况，</p>
<p>而这样一来，第i-1列数&#x3D;&#x3D;第i列数&#x3D;&#x3D;1，与前提条件相矛盾</p>
<p>所以得去掉下面一整行，而不是只去掉右边一个，来保证往左算的时候不产生矛盾</p>
<h3 id="问题3：求把n划分成k个不大于m的互不相同正整数的方案数"><a href="#问题3：求把n划分成k个不大于m的互不相同正整数的方案数" class="headerlink" title="问题3：求把n划分成k个不大于m的互不相同正整数的方案数"></a>问题3：求把n划分成k个不大于m的互不相同正整数的方案数</h3><p>暴力的就不写了<del>懒</del></p>
<p>将问题2的式子再拿来修修补补</p>
<p>在原来的基础上把超过m的情况减掉就行了</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6k7nr8tu.png"></p>
<p>式子为dp[i][j]&#x3D;dp[i-j][j]+dp[i-j][j-1]-dp[i-(m+1)][j-1]</p>
<h3 id="老师的寄语"><a href="#老师的寄语" class="headerlink" title="老师的寄语"></a>老师的寄语</h3><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ok5ob668.png"></p>
<h3 id="问题4：求把n划分成k个奇数的方案数（可重复数字纯奇纯偶划分）"><a href="#问题4：求把n划分成k个奇数的方案数（可重复数字纯奇纯偶划分）" class="headerlink" title="问题4：求把n划分成k个奇数的方案数（可重复数字纯奇纯偶划分）"></a>问题4：求把n划分成k个奇数的方案数（可重复数字纯奇纯偶划分）</h3><p><del>其实我觉得这题比前面几题还简单些(</del></p>
<p>设 g[i][j]:将i划分为j个偶数</p>
<p>f[i][j]:将i划分为j个奇数</p>
<p>如图</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zdyedqbc.png"></p>
<p>左图对应i是偶数的情况：g[i][j]&#x3D;f[i-j][j]</p>
<p>右图对应i是奇数的情况：f[i][j]&#x3D;f[i-1][j-1]+g[i-j][j]</p>
<p>（不可重复也是一样的）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://yupannn.github.io/2023/07/16/dpkuahao/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yupannn">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="盂盘的blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 盂盘的blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/16/dpkuahao/" class="post-title-link" itemprop="url">【DP专题】括号序列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-16 17:15:44" itemprop="dateCreated datePublished" datetime="2023-07-16T17:15:44+08:00">2023-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-06 17:20:09" itemprop="dateModified" datetime="2024-10-06T17:20:09+08:00">2024-10-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><del>小小括号能有什么坏心思呢</del></p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>括号序列问题就是：在给定条件下求合法括号序列（的个数）</p>
<p>括号序列当然就是序列中只有左括号（“（”）和右括号（“）”）这两种字符的序列</p>
<p>我们将合法的括号序列定义为：</p>
<p>把左括号看作+1，把右括号看作-1，保证任意一个前缀和大于等于0，且总和为0的括号序列</p>
<p>例：合法： （）、（（））、（）（（）（））……</p>
<p>不合法： （、（（）、）（）、（）（））……</p>
<p>毕竟我们实际上并不在意左右括号长什么样子，只关心它们之间的关系，</p>
<p>所以可以用其他任何满足这些关系的一对东西来替代：</p>
<p>贴了一段题里的描述：</p>
<ol>
<li><p>空串是合法的括号序列</p>
</li>
<li><p>若字符串 S 是合法括号序列，那么 [ S ]和 ( S ) 也都是合法的括号序列</p>
</li>
<li><p>若字符串 A 和 B 都是合法的括号序列，那么 AB（两字符串拼接起来）也是合法的括号序列</p>
</li>
</ol>
<h3 id="浅试一下"><a href="#浅试一下" class="headerlink" title="浅试一下"></a>浅试一下</h3><p>题目：Codeforces314E</p>
<p><del>本篇既然叫DP专题当然要用DP呗</del></p>
<p>考虑DP的原因主要在于，一条括号连缀而下，无后效性非常清楚非常完美</p>
<p>想象从左往右递推时每遇到一个右括号就把左边还留着的左括号消去一个</p>
<p>令dp[i][j]表示当前到第i个字符，现在左边还剩下j个左括号</p>
<p>（如果在递推时，出现 j&lt;0 的情况，说明右括号多出来了，而左边的左括号已经消光了不能再与它匹配，可以判断此括号序列不存在合法的情况）</p>
<p>那么分三种情况考虑</p>
<p>若第i+1个字符是左括号，则能转移到dp[i+1][j+1]</p>
<p>若第i+1个字符是右括号，则能转移到dp[i+1][j-1]</p>
<p>若第i+1个字符是问号，则能转移到dp[i+1][j-1]与dp[i+1][j+1]</p>
<p>最终dp[n][0]就是方案总数啦</p>
<p>时间复杂度为 O(n^2)</p>
<h3 id="得寸后再进一尺"><a href="#得寸后再进一尺" class="headerlink" title="得寸后再进一尺"></a>得寸后再进一尺</h3><p>题目：bzoj4922</p>
<p>表面上说求括号序列，其实和上面的完全不同</p>
<p>首先注意到输入给的括号序列不一定合法</p>
<p>为了看得清楚些，（反正每个序列内部的合法序列并不影响判断序列之间连起来是否合法）</p>
<p>对于每个括号序列，把左边的左括号和右边的右括号对消，最后能得到一坨这样的东西： </p>
<p>))…))((…(( </p>
<p>就是x个右括号然后y个左括号，记作(x,y)</p>
<p>好吧，先别想着枚举和图论，我们还是要不忘初心（DP）</p>
<p>首先设计状态时肯定有“从前往后考虑每一个序列”这一维，1～n，O(N)</p>
<p>那第二维呢？</p>
<p>瞎想一下后想到已考虑过的左括号和右括号的个数</p>
<p>但三维略大了吧……得把后面两个合并成一维</p>
<p>又想到前面有个+1和-1的那个性质</p>
<p>可以把第二维设为左右括号个数之差，即已考虑过的序列整体的前缀和<br>我们还是把左括号看成+1，右括号看成-1，同样是保证任意一个前缀大于等于0，且总和为0。 </p>
<p>那就是每一个给定的序列都是 先-Li再+Ri，Li是对消后左端右括号的数量，Li是对消后右端左括号的数量</p>
<p>然后依次拼起来之后任何一个前缀都大于等于0</p>
<p>设f[i][j]为 前i个括号序列-1与+1的和为j个时选出括号序列最长的长度和</p>
<p>也就是 前i个括号序列左括号比右括号多j个时的最长的长度和</p>
<p>转移时考虑下一个括号序列选不选即可</p>
<p>Len[i]为排完序后第i个括号序列的长度</p>
<p>f[i+1][j-L[i+1]+R[i+1]]&lt;–f[i][j] + len[i+1] (j&gt;&#x3D;L[i+1]) </p>
<p>f[i+1][j]&lt;–f[i][j]</p>
<p>最后答案就是f[n][0]</p>
<p>等等，我们再重看一下题目，它输入时可没指定这些序列的顺序啊！</p>
<p>我们刚咋就默认了按输入的顺序从左往右DP呢……</p>
<p>难道要枚举序列的初始顺序再分别DP吗？</p>
<p>当然不用！</p>
<h3 id="曲线救国"><a href="#曲线救国" class="headerlink" title="曲线救国"></a>曲线救国</h3><p>先来看另一道貌似风马牛不相及的题目</p>
<p>BZOJ3709</p>
<p>其实这两道题实质上完全相同</p>
<p>每只怪物相当于一段对消过后的括号序列，比如 ）））（（（</p>
<p>左边的右括号相当于-1，有几个右括号就代表回血之前消耗了多少血</p>
<p>右边的左括号相当于+1，有几个左括号就代表回血回了多少血</p>
<p>初始的血量就相当于初始时已经有一段对应长度的左括号了</p>
<p>这样一来，这道题就转变成了求</p>
<p>是否存在一种顺序，使得连括号序列时（不管在哪一个序列的哪一个括号上）不会出现前缀和小于0的情况</p>
<p>现在暂时忘掉什么括号序列，关注这道题本身！</p>
<p>发现我们竟然可以直接贪心！</p>
<p>怪兽可分为两种，一种是杀了它可以加血的，另一种是掉血的</p>
<p>容易想到最优策略应该是先杀那些可以加血的，再杀另一种</p>
<p>1：如果a[i]-d[i]&gt;0，说明打掉这个怪兽有血可恢复，那么血量会变多</p>
<p>明显我们按照伤害d[i]从小到大排序即可，然后一个个杀下来</p>
<p>2：如果a[i]-d[i]&lt;0，说明会亏血</p>
<p>一个精妙的想法就是，最后剩余的血量值，假设是x，那么x是固定的，然后可以看作初始血量为x，怪兽的属性a,d交换，这样就和上一种情况一样了，有一个形象的称呼：“时光倒流”（如图）</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/cz15ya40.png"></p>
<p>既然这题可以这样排序以确保最优策略，那括号序列那道题也能这样排！</p>
<p>对括号序列排序：</p>
<p>1.连了之后能增加左括号数量的排在前，会减少左括号的排在后</p>
<p>2.对于能增加左括号数量的序列，再按这个序列自身左括号的数量从小到大排</p>
<p>3.对于能减少左括号数量的序列，按这个序列自身右括号的数量从大到小排</p>
<p>排完序后再从左往右DP</p>
<p>DP的状态数为N*len，转移的时间复杂度为O(len)</p>
<p>复杂度O(N<em>len</em>len)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/default-index/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yupannn</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
